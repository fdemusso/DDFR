{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DDFR Backend Documentation","text":"<p>Welcome to the official documentation for the DDFR (Face Recognition) Backend API.</p>"},{"location":"#overview","title":"Overview","text":"<p>The DDFR backend is a FastAPI-based application providing face recognition and person management capabilities. It uses MongoDB for data storage, InsightFace for face detection and embedding extraction, and FAISS for efficient similarity search.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The backend is organized into the following modules:</p> <ul> <li>Configuration (<code>config</code>): Application settings and environment variables</li> <li>API (<code>routers</code>): REST and WebSocket endpoints</li> <li>Services (<code>services</code>): Core business logic (database, face recognition)</li> <li>Models (<code>models</code>): Data models and schemas</li> <li>Utils (<code>utils</code>): Utility functions and constants</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11.9 (required - the project is not tested on other versions)</li> <li>MongoDB</li> <li>Visual C++ Build Tools (Windows) or appropriate build tools (Mac/Linux)</li> <li>Required Python packages (installed automatically via setup scripts)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>IMPORTANT: Dependency installation must be done ONLY via the provided setup scripts (<code>setup.bat</code> for Windows or <code>setup.sh</code> for Mac/Linux). Manual installation should only be attempted after carefully reading the requirements files and understanding what is needed for your specific machine configuration.</p>"},{"location":"#windows","title":"Windows","text":"<ol> <li>Run the setup script: <pre><code>setup.bat\n</code></pre></li> </ol> <p>This script will: - Verify Visual C++ Build Tools installation - Check Python 3.11.9 installation - Create virtual environment - Detect hardware (NVIDIA GPU vs CPU/DirectML) - Install appropriate dependencies from <code>requirements/universal.txt</code> or <code>requirements/nvidia.txt</code></p>"},{"location":"#maclinux","title":"Mac/Linux","text":"<ol> <li>Run the setup script: <pre><code>chmod +x setup.sh\n./setup.sh\n</code></pre></li> </ol> <p>This script will: - Verify Python 3.11.9 installation - Detect OS and architecture (Apple Silicon vs Intel, Linux) - Create virtual environment - Detect hardware (NVIDIA GPU vs CPU) - Install appropriate dependencies from <code>requirements/mac.txt</code>, <code>requirements/nvidia.txt</code>, or <code>requirements/base.txt</code></p>"},{"location":"#manual-installation-advanced","title":"Manual Installation (Advanced)","text":"<p>If you need to install dependencies manually, carefully review the requirements files: - <code>requirements/base.txt</code> - Base dependencies for CPU - <code>requirements/nvidia.txt</code> - Dependencies for NVIDIA GPU support - <code>requirements/mac.txt</code> - Dependencies for macOS (Apple Silicon) - <code>requirements/universal.txt</code> - Universal dependencies for Windows (CPU/DirectML)</p> <p>Note: Manual installation requires understanding which file is appropriate for your system configuration.</p>"},{"location":"#configuration","title":"Configuration","text":"<ol> <li>Configure environment variables in <code>.env</code> file (create in <code>backend/app/</code> directory): <pre><code>DB_URL=mongodb://localhost:27017/\nDB_NAME=ddfr_db\nDB_COLLECTION=people\nDB_HASH=\"300a31fbdc6f3ff4fb27625c2ed49fdc\"\nLOG_LOGFOLDER=logs\nAPP_HOST=0.0.0.0\nAPP_PORT=8000\nAPP_DEBUG=false\n</code></pre></li> </ol> <p>See the Configuration section for a complete list of available environment variables.</p> <ol> <li>Activate virtual environment:</li> <li>Windows: <code>.venv\\Scripts\\activate</code></li> <li> <p>Mac/Linux: <code>source .venv/bin/activate</code></p> </li> <li> <p>Run the application: <pre><code>cd backend/app\npython -m main\n</code></pre></p> </li> </ol>"},{"location":"#features","title":"Features","text":"<ul> <li>Face Detection: Real-time face detection using InsightFace</li> <li>Face Recognition: Person identification using embedding similarity search</li> <li>Person Management: CRUD operations for person data</li> <li>WebSocket API: Real-time face recognition over WebSocket</li> <li>REST API: Standard HTTP endpoints for data management</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>Navigate through the documentation using the sidebar to explore:</p> <ul> <li>Configuration options and settings</li> <li>API endpoints and WebSocket connections</li> <li>Service implementations and methods</li> <li>Data models and validation rules</li> <li>Utility functions and constants</li> </ul>"},{"location":"api/routes/","title":"REST API Routes","text":"<p>REST API endpoints for the DDFR face recognition application.</p>"},{"location":"api/routes/#overview","title":"Overview","text":"<p>The REST API provides standard HTTP endpoints for application interaction. Currently, the API includes a simple health check endpoint. Additional endpoints for person management and face recognition operations may be added in future versions.</p>"},{"location":"api/routes/#base-url","title":"Base URL","text":"<p>All API endpoints are prefixed with the application base URL: - Development: <code>http://localhost:8000</code> - Production: Configure via <code>APP_HOST</code> and <code>APP_PORT</code> environment variables</p>"},{"location":"api/routes/#cors-configuration","title":"CORS Configuration","text":"<p>The API is configured with CORS middleware that allows: - All origins (<code>*</code>) - All methods (<code>*</code>) - All headers (<code>*</code>) - Credentials enabled</p> <p>This configuration is suitable for development. For production, consider restricting allowed origins.</p>"},{"location":"api/routes/#endpoints","title":"Endpoints","text":""},{"location":"api/routes/#health-check","title":"Health Check","text":""},{"location":"api/routes/#get","title":"<code>GET /</code>","text":"<p>Returns a simple greeting message indicating the server is active.</p> <p>Request: <pre><code>GET / HTTP/1.1\nHost: localhost:8000\n</code></pre></p> <p>Response: <pre><code>{\n  \"message\": \"Hello World\"\n}\n</code></pre></p> <p>Status Codes: - <code>200 OK</code>: Server is running and responding</p> <p>Use Cases: - Health check for monitoring systems - Verify API server availability - Simple connectivity test</p>"},{"location":"api/routes/#api-reference","title":"API Reference","text":""},{"location":"api/routes/#app.routers.route.router","title":"app.routers.route.router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter()\n</code></pre>"},{"location":"api/routes/#app.routers.route.home","title":"app.routers.route.home  <code>async</code>","text":"<pre><code>home()\n</code></pre> <p>Return home endpoint greeting message.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing a greeting message.</p> Source code in <code>backend/app/routers/route.py</code> <pre><code>@router.get(\"/\")\nasync def home() -&gt; dict:\n    \"\"\"Return home endpoint greeting message.\n\n    Returns:\n        dict: A dictionary containing a greeting message.\n\n    \"\"\"\n    return {\"message\": \"Hello World\"}\n</code></pre>"},{"location":"api/websocket/","title":"WebSocket API","text":"<p>WebSocket endpoint for real-time face recognition and person identification.</p>"},{"location":"api/websocket/#overview","title":"Overview","text":"<p>The WebSocket API provides a bidirectional communication channel for real-time face detection and recognition. This is the core functionality of the DDFR application, enabling continuous video frame processing and instant person identification.</p>"},{"location":"api/websocket/#architecture","title":"Architecture","text":"<p>The WebSocket implementation uses an asynchronous processing model:</p> <ol> <li>Client Connection: Client establishes WebSocket connection to <code>/ws</code></li> <li>Frame Transmission: Client sends binary image data (JPEG/PNG encoded frames)</li> <li>Asynchronous Processing: Server processes frames in a thread pool executor to avoid blocking</li> <li>Response Transmission: Server returns JSON results with detected faces and identities</li> <li>Rate Limiting: Handled client-side (recommended: 50ms intervals = 20 FPS)</li> </ol>"},{"location":"api/websocket/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/websocket/#thread-pool-configuration","title":"Thread Pool Configuration","text":"<ul> <li>Executor: Single-threaded (<code>max_workers=1</code>) to ensure sequential frame processing</li> <li>Rationale: Prevents race conditions and ensures consistent state during face recognition</li> <li>Note: NumPy threading is disabled via environment variables to prevent conflicts</li> </ul>"},{"location":"api/websocket/#processing-pipeline","title":"Processing Pipeline","text":"<ol> <li>Image Decoding: Binary bytes \u2192 OpenCV BGR frame</li> <li>Face Detection: InsightFace model detects faces in frame</li> <li>Embedding Extraction: Face features extracted as embedding vectors</li> <li>Person Identification: FAISS/Numpy similarity search against database</li> <li>Response Formatting: Results serialized as JSON</li> </ol>"},{"location":"api/websocket/#batch-processing","title":"Batch Processing","text":"<p>When multiple faces are detected in a single frame: - All faces are processed in parallel during embedding extraction - Batch identification is performed using vectorized operations - Results maintain face-to-identity mapping</p>"},{"location":"api/websocket/#connection","title":"Connection","text":""},{"location":"api/websocket/#endpoint","title":"Endpoint","text":"<pre><code>ws://localhost:8000/ws\n</code></pre> <p>For HTTPS: <pre><code>wss://your-domain.com/ws\n</code></pre></p>"},{"location":"api/websocket/#connection-lifecycle","title":"Connection Lifecycle","text":"<ol> <li>Connect: Client initiates WebSocket handshake</li> <li>Accept: Server accepts connection (<code>websocket.accept()</code>)</li> <li>Loop: Continuous frame processing until disconnect</li> <li>Disconnect: Graceful handling with <code>WebSocketDisconnect</code> exception</li> </ol>"},{"location":"api/websocket/#message-protocol","title":"Message Protocol","text":""},{"location":"api/websocket/#client-server-binary","title":"Client \u2192 Server (Binary)","text":"<p>Format: Raw binary image data</p> <p>Supported Formats: - JPEG encoded images - PNG encoded images - Any format supported by OpenCV <code>imdecode()</code></p> <p>Example (JavaScript): <pre><code>const canvas = document.getElementById('video-canvas');\ncanvas.toBlob((blob) =&gt; {\n  blob.arrayBuffer().then((buffer) =&gt; {\n    websocket.send(buffer);\n  });\n}, 'image/jpeg', 0.8);\n</code></pre></p> <p>Example (Python): <pre><code>import cv2\nimport websockets\n\nframe = cv2.imread('image.jpg')\n_, buffer = cv2.imencode('.jpg', frame)\nawait websocket.send(buffer.tobytes())\n</code></pre></p>"},{"location":"api/websocket/#server-client-json","title":"Server \u2192 Client (JSON)","text":"<p>Format: JSON object with status and faces array</p> <p>Response Structure: <pre><code>{\n  \"status\": \"ok\",\n  \"faces\": [\n    {\n      \"id\": \"123_456\",\n      \"top\": 100,\n      \"right\": 300,\n      \"bottom\": 400,\n      \"left\": 200,\n      \"name\": \"John\",\n      \"surname\": \"Doe\",\n      \"age\": 30,\n      \"relationship\": \"amico\",\n      \"role\": \"guest\"\n    }\n  ]\n}\n</code></pre></p> <p>Unknown Person Structure: <pre><code>{\n  \"status\": \"ok\",\n  \"faces\": [\n    {\n      \"id\": \"123_456\",\n      \"top\": 100,\n      \"right\": 300,\n      \"bottom\": 400,\n      \"left\": 200,\n      \"name\": \"Unknown\",\n      \"surname\": null,\n      \"age\": 0,\n      \"relationship\": null,\n      \"role\": null\n    }\n  ]\n}\n</code></pre></p> <p>Empty Response (No faces detected): <pre><code>{\n  \"status\": \"ok\",\n  \"faces\": []\n}\n</code></pre></p> <p>Error Response (Decoding failure): Returns <code>null</code> (connection remains open, client should skip frame)</p>"},{"location":"api/websocket/#field-descriptions","title":"Field Descriptions","text":""},{"location":"api/websocket/#face-object","title":"Face Object","text":"Field Type Description <code>id</code> string Unique identifier for the face in format <code>\"{top}_{left}\"</code> (pixel coordinates) <code>top</code> integer Top Y coordinate of bounding box <code>right</code> integer Right X coordinate of bounding box <code>bottom</code> integer Bottom Y coordinate of bounding box <code>left</code> integer Left X coordinate of bounding box <code>name</code> string Person's first name (or \"Unknown\" if not identified) <code>surname</code> string Person's last name (or null if not identified) <code>age</code> integer Calculated age based on birthday (or 0 if not identified) <code>relationship</code> string Relationship type enum value (or null if not identified) <code>role</code> string Person role enum value (\"user\" or \"guest\", or null if not identified)"},{"location":"api/websocket/#face-id-format","title":"Face ID Format","text":"<p>The <code>id</code> field uses pixel coordinates: <code>\"{top}_{left}\"</code> (e.g., <code>\"100_200\"</code>). This provides: - Uniqueness within a frame - Traceability for debugging - Client-side face tracking capabilities</p>"},{"location":"api/websocket/#identification-process","title":"Identification Process","text":""},{"location":"api/websocket/#threshold-configuration","title":"Threshold Configuration","text":"<p>The identification uses a similarity threshold of 0.4 (hardcoded in <code>process_image_sync</code>). This is more lenient than the default <code>APP_TOLLERANCE</code> setting to improve recognition accuracy.</p> <p>Similarity Score Range: - <code>0.0</code> - <code>1.0</code> (1.0 = identical match) - Threshold <code>0.4</code> means matches above 40% similarity are accepted</p>"},{"location":"api/websocket/#database-states","title":"Database States","text":"<ol> <li>Database Active (<code>feature_matrix is not None</code>):</li> <li>Full identification pipeline active</li> <li>FAISS or NumPy similarity search performed</li> <li> <p>Matched persons returned with data</p> </li> <li> <p>Database Empty (<code>feature_matrix is None</code>):</p> </li> <li>Fallback mode: detection only</li> <li>Faces detected but no identification attempted</li> <li>All faces marked as \"Unknown\"</li> <li>Error logged for monitoring</li> </ol>"},{"location":"api/websocket/#batch-processing_1","title":"Batch Processing","text":"<p>When multiple faces are detected: - All embeddings extracted simultaneously - Single batch identification call for efficiency - Results maintain order: <code>identities[i]</code> corresponds to <code>faces[i]</code></p>"},{"location":"api/websocket/#error-handling","title":"Error Handling","text":""},{"location":"api/websocket/#image-decoding-errors","title":"Image Decoding Errors","text":"<ul> <li>Cause: Invalid image format or corrupted data</li> <li>Behavior: Function returns <code>None</code>, error logged</li> <li>Client Action: Skip frame, continue with next</li> </ul>"},{"location":"api/websocket/#database-errors","title":"Database Errors","text":"<ul> <li>Cause: <code>feature_matrix</code> unavailable or empty</li> <li>Behavior: Fallback to detection-only mode, error logged</li> <li>Client Action: Receive faces with \"Unknown\" identity</li> </ul>"},{"location":"api/websocket/#websocket-disconnection","title":"WebSocket Disconnection","text":"<ul> <li>Cause: Client closes connection or network interruption</li> <li>Behavior: <code>WebSocketDisconnect</code> exception caught, connection cleaned up</li> <li>Logging: Info-level message recorded</li> </ul>"},{"location":"api/websocket/#processing-errors","title":"Processing Errors","text":"<ul> <li>Cause: Unexpected exceptions during processing</li> <li>Behavior: Error logged, connection remains open</li> <li>Client Action: May receive null response, should handle gracefully</li> </ul>"},{"location":"api/websocket/#rate-limiting","title":"Rate Limiting","text":"<p>Client-Side Responsibility: Rate limiting is handled on the frontend to maintain responsive UI.</p> <p>Recommended Rate: 50ms intervals (20 FPS)</p> <p>Example Implementation: <pre><code>let lastSend = 0;\nconst interval = 50; // ms\n\nfunction sendFrame() {\n  const now = Date.now();\n  if (now - lastSend &gt;= interval) {\n    websocket.send(frameData);\n    lastSend = now;\n  }\n}\n</code></pre></p>"},{"location":"api/websocket/#example-usage","title":"Example Usage","text":""},{"location":"api/websocket/#javascriptwebsocket-api","title":"JavaScript/WebSocket API","text":"<pre><code>const ws = new WebSocket('ws://localhost:8000/ws');\n\nws.onopen = () =&gt; {\n  console.log('WebSocket connected');\n\n  // Start sending frames from video\n  setInterval(() =&gt; {\n    const canvas = document.getElementById('canvas');\n    canvas.toBlob((blob) =&gt; {\n      blob.arrayBuffer().then((buffer) =&gt; {\n        ws.send(buffer);\n      });\n    }, 'image/jpeg', 0.8);\n  }, 50); // 20 FPS\n};\n\nws.onmessage = (event) =&gt; {\n  const result = JSON.parse(event.data);\n  console.log('Detected faces:', result.faces);\n\n  result.faces.forEach(face =&gt; {\n    if (face.name !== 'Unknown') {\n      console.log(`Identified: ${face.name} ${face.surname}`);\n    }\n  });\n};\n\nws.onerror = (error) =&gt; {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = () =&gt; {\n  console.log('WebSocket disconnected');\n};\n</code></pre>"},{"location":"api/websocket/#python-example","title":"Python Example","text":"<pre><code>import asyncio\nimport websockets\nimport cv2\n\nasync def send_frames():\n    uri = \"ws://localhost:8000/ws\"\n    async with websockets.connect(uri) as websocket:\n        cap = cv2.VideoCapture(0)\n\n        try:\n            while True:\n                ret, frame = cap.read()\n                if not ret:\n                    break\n\n                # Encode frame as JPEG\n                _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 80])\n\n                # Send binary data\n                await websocket.send(buffer.tobytes())\n\n                # Receive response\n                response = await websocket.recv()\n                result = json.loads(response)\n\n                print(f\"Faces detected: {len(result['faces'])}\")\n\n                # Rate limiting: ~20 FPS\n                await asyncio.sleep(0.05)\n\n        finally:\n            cap.release()\n\nasyncio.run(send_frames())\n</code></pre>"},{"location":"api/websocket/#implementation-details","title":"Implementation Details","text":""},{"location":"api/websocket/#thread-pool-executor","title":"Thread Pool Executor","text":"<p>The synchronous <code>process_image_sync</code> function is executed in a thread pool to avoid blocking the event loop:</p> <pre><code>result = await loop.run_in_executor(executor, process_image_sync, data)\n</code></pre> <p>Benefits: - Non-blocking I/O for WebSocket operations - CPU-intensive processing in separate thread - Maintains async architecture</p>"},{"location":"api/websocket/#numpy-threading-disabled","title":"NumPy Threading Disabled","text":"<p>Environment variables are set to prevent NumPy threading conflicts: <pre><code>os.environ[\"OMP_NUM_THREADS\"] = \"1\"\nos.environ[\"OPENBLAS_NUM_THREADS\"] = \"1\"\n# ... etc\n</code></pre></p> <p>Reason: Prevents GIL contention and ensures consistent behavior.</p>"},{"location":"api/websocket/#api-reference","title":"API Reference","text":""},{"location":"api/websocket/#app.routers.websocket.router","title":"app.routers.websocket.router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter()\n</code></pre>"},{"location":"api/websocket/#app.routers.websocket.websocket_endpoint","title":"app.routers.websocket.websocket_endpoint  <code>async</code>","text":"<pre><code>websocket_endpoint(websocket)\n</code></pre> <p>WebSocket endpoint for real-time face recognition.</p> <p>Accepts binary image data over WebSocket connection, processes frames asynchronously for face detection and recognition, and returns results in JSON format. Rate limiting is handled on the frontend (50ms = 20 FPS).</p> <p>Parameters:</p> Name Type Description Default <code>websocket</code> <code>WebSocket</code> <p>FastAPI WebSocket connection instance.</p> required <p>Raises:</p> Type Description <code>WebSocketDisconnect</code> <p>When client disconnects from the WebSocket.</p> <code>Exception</code> <p>Logs any errors during image processing or WebSocket communication.</p> Source code in <code>backend/app/routers/websocket.py</code> <pre><code>@router.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"WebSocket endpoint for real-time face recognition.\n\n    Accepts binary image data over WebSocket connection, processes frames\n    asynchronously for face detection and recognition, and returns results in JSON format.\n    Rate limiting is handled on the frontend (50ms = 20 FPS).\n\n    Args:\n        websocket (WebSocket): FastAPI WebSocket connection instance.\n\n    Raises:\n        WebSocketDisconnect: When client disconnects from the WebSocket.\n        Exception: Logs any errors during image processing or WebSocket communication.\n\n    \"\"\"\n    await websocket.accept()\n    loop = asyncio.get_event_loop()\n\n    try:\n        while True:\n            data = await websocket.receive_bytes()\n\n            # Il rate limiting \u00e8 gestito lato frontend (50ms = 20 FPS)\n            result = await loop.run_in_executor(executor, process_image_sync, data)\n\n            if result:\n                await websocket.send_json(result)\n\n    except WebSocketDisconnect:\n        logger.info(\"Client disconnesso\")\n    except Exception as e:\n        logger.error(f\"Errore WebSocket: {e}\")\n</code></pre>"},{"location":"api/websocket/#app.routers.websocket.process_image_sync","title":"app.routers.websocket.process_image_sync","text":"<pre><code>process_image_sync(image_bytes)\n</code></pre> <p>Process image bytes synchronously for face detection and recognition.</p> <p>Decodes image bytes, detects faces, and identifies persons using the face engine. Returns face detection results with bounding boxes and person information.</p> <p>Parameters:</p> Name Type Description Default <code>image_bytes</code> <code>bytes</code> <p>Raw image bytes to process.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary containing status and list of detected faces. Format: {\"status\": \"ok\", \"faces\": [{\"id\": str, \"top\": int, \"right\": int,  \"bottom\": int, \"left\": int, \"name\": str, \"surname\": str, \"age\": int, \"relationship\": str, \"role\": str}, ...]} Returns None if image decoding fails.</p> Source code in <code>backend/app/routers/websocket.py</code> <pre><code>def process_image_sync(image_bytes: bytes) -&gt; dict | None:\n    \"\"\"Process image bytes synchronously for face detection and recognition.\n\n    Decodes image bytes, detects faces, and identifies persons using the face engine.\n    Returns face detection results with bounding boxes and person information.\n\n    Args:\n        image_bytes (bytes): Raw image bytes to process.\n\n    Returns:\n        dict | None: Dictionary containing status and list of detected faces.\n            Format: {\"status\": \"ok\", \"faces\": [{\"id\": str, \"top\": int, \"right\": int, \n            \"bottom\": int, \"left\": int, \"name\": str, \"surname\": str, \"age\": int,\n            \"relationship\": str, \"role\": str}, ...]}\n            Returns None if image decoding fails.\n\n    \"\"\"\n    try:\n        np_arr = np.frombuffer(image_bytes, np.uint8)\n        frame = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)\n\n        if frame is None:\n            return None\n    except Exception as e:\n        logger.error(f\"Errore parsing immagine: {e}\")\n        return None\n\n    faces: List[Face] = engine.analyze_frame(frame)\n    found_people_list: List[Tuple[Optional[Person], Face]] = []\n\n    # Nessun volto rilevato (uscita rapida)\n    if not faces:\n        return {\"status\": \"ok\", \"faces\": []}\n\n    # Abbiamo volti E il Database \u00e8 attivo -&gt; BATCH PROCESSING\n    if engine.feature_matrix is not None:\n        embeddings = [face.embedding for face in faces]\n        identities = engine.identify(embeddings, threshold=0.4)\n\n        for (found_person, score), face in zip(identities, faces):\n            found_people_list.append((found_person, face))\n\n    # Abbiamo volti MA il Database non c'\u00e8 (Fallback)\n    else:\n        logger.error(f\"feature_matrix None ma rilevati {len(faces)} volti\")\n        for face in faces:\n            found_people_list.append((None, face))\n\n    faces_data = []\n\n    for person_data, face in found_people_list:\n        bbox = face.bbox.astype(int)\n        left, top, right, bottom = int(bbox[0]), int(bbox[1]), int(bbox[2]), int(bbox[3])\n\n        face_dict = {\n            \"id\": f\"{top}_{left}\",\n            \"top\": top,\n            \"right\": right,\n            \"bottom\": bottom,\n            \"left\": left\n        }\n\n        if person_data is not None:\n            relationship = getattr(person_data.relationship, \"value\", person_data.relationship)\n            role = getattr(person_data.role, \"value\", person_data.role)\n\n            face_dict.update({\n                \"name\": person_data.name,\n                \"surname\": person_data.surname,\n                \"age\": person_data.age, \n                \"relationship\": relationship,\n                \"role\": role,\n            })\n        else:\n            face_dict.update({\n                \"name\": \"Unknown\",\n                \"surname\": None,\n                \"age\": 0,\n                \"relationship\": None,\n                \"role\": None,\n            })\n\n        faces_data.append(face_dict)\n\n    return {\"status\": \"ok\", \"faces\": faces_data}\n</code></pre>"},{"location":"config/config/","title":"Configuration","text":"<p>Configuration module for application settings.</p>"},{"location":"config/config/#environment-variables-env","title":"Environment Variables (.env)","text":"<p>The application configuration is managed through environment variables loaded from a <code>.env</code> file located in the <code>backend/app/</code> directory.</p>"},{"location":"config/config/#configuration-file-structure","title":"Configuration File Structure","text":"<p>Create a <code>.env</code> file in <code>backend/app/</code> with the following structure:</p> <pre><code># --- Database Section (Prefix: DB_) ---\nDB_URL=mongodb://localhost:27017/\nDB_NAME=ddfr_db\nDB_COLLECTION=people\nDB_HASH=\"300a31fbdc6f3ff4fb27625c2ed49fdc\"\n\n# --- Logging Section (Prefix: LOG_) ---\nLOG_LOGFOLDER=logs\n\n# --- API Section (Prefix: APP_) ---\nAPP_NAME=DDFR API\nAPP_VERSION=1.0.0\nAPP_DESCRIPTION=API for face recognition and person management\nAPP_TOLLERANCE=0.5\nAPP_DEBUG=false\nAPP_HOST=0.0.0.0\nAPP_PORT=8000\nAPP_USE_HTTPS=false\nAPP_KEYPATH=\nAPP_CERTPATH=\n</code></pre>"},{"location":"config/config/#variable-descriptions","title":"Variable Descriptions","text":""},{"location":"config/config/#database-settings-prefix-db_","title":"Database Settings (Prefix: <code>DB_</code>)","text":"<ul> <li><code>DB_URL</code> (string): MongoDB connection URL. </li> <li>Default: <code>\"mongodb://localhost:27017/\"</code></li> <li> <p>Example: <code>\"mongodb+srv://user:password@cluster.mongodb.net/\"</code></p> </li> <li> <p><code>DB_NAME</code> (string): Database name.</p> </li> <li> <p>Default: <code>\"ddfr_db\"</code></p> </li> <li> <p><code>DB_COLLECTION</code> (string): MongoDB collection name for storing person data.</p> </li> <li> <p>Default: <code>\"people\"</code></p> </li> <li> <p><code>DB_HASH</code> (string): Legacy hash value (currently not actively used, kept for backward compatibility).</p> </li> <li>Value: <code>\"300a31fbdc6f3ff4fb27625c2ed49fdc\"</code></li> </ul>"},{"location":"config/config/#logging-settings-prefix-log_","title":"Logging Settings (Prefix: <code>LOG_</code>)","text":"<ul> <li><code>LOG_LOGFOLDER</code> (string): Directory path for log files. If not specified, defaults to <code>logs-{timestamp}</code> in the backend directory.</li> <li>Example: <code>\"logs\"</code> or <code>\"C:/logs/ddfr\"</code></li> </ul>"},{"location":"config/config/#api-settings-prefix-app_","title":"API Settings (Prefix: <code>APP_</code>)","text":"<ul> <li><code>APP_NAME</code> (string): Application name displayed in API documentation.</li> <li> <p>Default: <code>\"DDFR API\"</code></p> </li> <li> <p><code>APP_VERSION</code> (string): Application version.</p> </li> <li> <p>Default: <code>\"1.0.0\"</code></p> </li> <li> <p><code>APP_DESCRIPTION</code> (string): Application description displayed in API documentation.</p> </li> <li> <p>Default: <code>\"API for face recognition and person management\"</code></p> </li> <li> <p><code>APP_TOLLERANCE</code> (float): Face recognition similarity threshold (0.0-1.0). Lower values are more strict.</p> </li> <li>Default: <code>0.5</code></li> <li>Recommended range: <code>0.4-0.6</code></li> <li> <p>\u26a0\ufe0f Deprecated: This setting is being phased out and used less frequently. Consider using hardcoded thresholds in the recognition service instead.</p> </li> <li> <p><code>APP_DEBUG</code> (boolean): Enable debug mode. When enabled, provides more verbose logging.</p> </li> <li>Default: <code>false</code></li> <li> <p>Values: <code>true</code> or <code>false</code></p> </li> <li> <p><code>APP_HOST</code> (string): Server host address to bind to.</p> </li> <li>Default: <code>\"0.0.0.0\"</code> (listens on all interfaces)</li> <li> <p>For localhost only: <code>\"127.0.0.1\"</code></p> </li> <li> <p><code>APP_PORT</code> (integer): Server port number.</p> </li> <li> <p>Default: <code>8000</code></p> </li> <li> <p><code>APP_USE_HTTPS</code> (boolean): Enable HTTPS support.</p> </li> <li>Default: <code>false</code></li> <li> <p>Values: <code>true</code> or <code>false</code></p> </li> <li> <p><code>APP_KEYPATH</code> (string, optional): Path to SSL private key file (required if <code>APP_USE_HTTPS=true</code>).</p> </li> <li>Default: <code>None</code> (empty)</li> <li> <p>Example: <code>\"C:/path/to/key.pem\"</code> (Windows) or <code>\"/path/to/key.pem\"</code> (Mac/Linux)</p> </li> <li> <p><code>APP_CERTPATH</code> (string, optional): Path to SSL certificate file (required if <code>APP_USE_HTTPS=true</code>).</p> </li> <li>Default: <code>None</code> (empty)</li> <li>Example: <code>\"C:/path/to/cert.pem\"</code> (Windows) or <code>\"/path/to/cert.pem\"</code> (Mac/Linux)</li> </ul>"},{"location":"config/config/#creating-ssl-certificates","title":"Creating SSL Certificates","text":"<p>To enable HTTPS, you need to generate SSL certificates. Here are some common approaches:</p>"},{"location":"config/config/#using-mkcert-recommended-for-development","title":"Using mkcert (Recommended for Development)","text":"<p>mkcert is a simple tool for making locally-trusted development certificates:</p> <ol> <li>Install mkcert:</li> <li>Windows: <code>choco install mkcert</code> or download from GitHub releases</li> <li>macOS: <code>brew install mkcert</code></li> <li> <p>Linux: See installation instructions</p> </li> <li> <p>Install the local CA:    <pre><code>mkcert -install\n</code></pre></p> </li> <li> <p>Generate certificate for your domain:    <pre><code>mkcert ddfr.local localhost 127.0.0.1 ::1\n</code></pre>    This creates <code>ddfr.local+2.pem</code> (certificate) and <code>ddfr.local+2-key.pem</code> (private key)</p> </li> <li> <p>Update your .env file:    <pre><code>APP_USE_HTTPS=true\nAPP_KEYPATH=/path/to/ddfr.local+2-key.pem\nAPP_CERTPATH=/path/to/ddfr.local+2.pem\n</code></pre></p> </li> </ol>"},{"location":"config/config/#using-openssl-manual","title":"Using OpenSSL (Manual)","text":"<p>For manual certificate generation using OpenSSL:</p> <ol> <li> <p>Generate a private key:    <pre><code>openssl genrsa -out key.pem 2048\n</code></pre></p> </li> <li> <p>Create a certificate signing request (CSR):    <pre><code>openssl req -new -key key.pem -out csr.pem\n</code></pre></p> </li> <li> <p>Generate a self-signed certificate:    <pre><code>openssl x509 -req -days 365 -in csr.pem -signkey key.pem -out cert.pem\n</code></pre></p> </li> </ol> <p>Note: Self-signed certificates will show security warnings in browsers. For production, use certificates from a trusted Certificate Authority (CA).</p>"},{"location":"config/config/#production-certificates","title":"Production Certificates","text":"<p>For production environments, consider: - Let's Encrypt: Free, automated SSL certificates - https://letsencrypt.org/ - Cloudflare: Provides free SSL certificates for proxied domains - Commercial CAs: Various providers offer SSL certificates (DigiCert, GlobalSign, etc.)</p>"},{"location":"config/config/#additional-resources","title":"Additional Resources","text":"<ul> <li>mkcert Documentation</li> <li>OpenSSL Certificate Authority</li> <li>FastAPI HTTPS Documentation</li> </ul>"},{"location":"config/config/#configuration-classes","title":"Configuration Classes","text":""},{"location":"config/config/#databasesettings","title":"DatabaseSettings","text":""},{"location":"config/config/#app.config.DatabaseSettings","title":"app.config.DatabaseSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Database connection configuration settings for MongoDB.</p> <p>Loads settings from .env file using the \"DB_\" prefix. All environment variables must be prefixed with DB_ to be recognized.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>MongoDB connection URL. Default: \"mongodb://localhost:27017/\".</p> <code>name</code> <code>str</code> <p>Database name. Default: \"ddfr_db\".</p> <code>collection</code> <code>str</code> <p>MongoDB collection name. Default: \"people\".</p> <code>hash</code> <code>str</code> <p>Hash for data security. Required, no default value.</p> Source code in <code>backend/app/config.py</code> <pre><code>class DatabaseSettings(BaseSettings):\n    \"\"\"Database connection configuration settings for MongoDB.\n\n    Loads settings from .env file using the \"DB_\" prefix.\n    All environment variables must be prefixed with DB_ to be recognized.\n\n    Attributes:\n        url (str): MongoDB connection URL. Default: \"mongodb://localhost:27017/\".\n        name (str): Database name. Default: \"ddfr_db\".\n        collection (str): MongoDB collection name. Default: \"people\".\n        hash (str): Hash for data security. Required, no default value.\n\n    \"\"\"\n\n    url: str = \"mongodb://localhost:27017/\"\n    name: str = \"ddfr_db\"\n    collection: str = \"people\"\n    hash: str \n\n    class Config:\n        env_prefix = \"DB_\"\n        env_file = ENV_FILE_PATH\n        env_file_encoding = 'utf-8'\n        extra = \"ignore\"\n</code></pre>"},{"location":"config/config/#pathsettings","title":"PathSettings","text":""},{"location":"config/config/#app.config.PathSettings","title":"app.config.PathSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>File system path configuration settings.</p> <p>Loads settings from .env file using the \"LOG_\" prefix. All environment variables must be prefixed with LOG_ to be recognized.</p> <p>Attributes:</p> Name Type Description <code>logfolder</code> <code>str</code> <p>Directory path for log files. Default: \"logs-{timestamp}\" in backend directory.</p> <code>imgsfolder</code> <code>str</code> <p>Directory path for image storage. Default: \"img\" in app directory.</p> Source code in <code>backend/app/config.py</code> <pre><code>class PathSettings(BaseSettings):\n    \"\"\"File system path configuration settings.\n\n    Loads settings from .env file using the \"LOG_\" prefix.\n    All environment variables must be prefixed with LOG_ to be recognized.\n\n    Attributes:\n        logfolder (str): Directory path for log files. Default: \"logs-{timestamp}\" in backend directory.\n        imgsfolder (str): Directory path for image storage. Default: \"img\" in app directory.\n\n    \"\"\"\n\n    logfolder: str = os.path.join(BACKEND_DIR, f\"logs-{_STARTUP_TIMESTAMP}\")\n    imgsfolder: str = os.path.join(BASE_DIR, \"img\")\n\n    class Config:\n        env_prefix = \"LOG_\"\n        env_file = ENV_FILE_PATH\n        env_file_encoding = 'utf-8'\n        extra = \"ignore\"\n</code></pre>"},{"location":"config/config/#apisettings","title":"APISettings","text":""},{"location":"config/config/#app.config.APISettings","title":"app.config.APISettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>API application configuration settings.</p> <p>Loads settings from .env file using the \"APP_\" prefix. All environment variables must be prefixed with APP_ to be recognized.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>API server host address. Default: \"192.168.1.69\".</p> <code>port</code> <code>int</code> <p>API server port number. Default: 8000.</p> <code>app_name</code> <code>str</code> <p>Application name. Default: \"DDFR API\".</p> <code>description</code> <code>str</code> <p>API description. Default: \"API per il riconoscimento facciale e la gestione delle persone\".</p> <code>app_version</code> <code>str</code> <p>Application version. Default: \"1.0.0\".</p> <code>tollerance</code> <code>float</code> <p>Face recognition tolerance threshold. Default: 0.5.</p> <code>debug</code> <code>bool</code> <p>Enable debug mode. Default: False.</p> <code>use_https</code> <code>bool</code> <p>Enable HTTPS. Default: False.</p> <code>keypath</code> <code>Optional[str]</code> <p>Path to SSL private key file. Default: None.</p> <code>certpath</code> <code>Optional[str]</code> <p>Path to SSL certificate file. Default: None.</p> Source code in <code>backend/app/config.py</code> <pre><code>class APISettings(BaseSettings):\n    \"\"\"API application configuration settings.\n\n    Loads settings from .env file using the \"APP_\" prefix.\n    All environment variables must be prefixed with APP_ to be recognized.\n\n    Attributes:\n        host (str): API server host address. Default: \"192.168.1.69\".\n        port (int): API server port number. Default: 8000.\n        app_name (str): Application name. Default: \"DDFR API\".\n        description (str): API description. Default: \"API per il riconoscimento facciale e la gestione delle persone\".\n        app_version (str): Application version. Default: \"1.0.0\".\n        tollerance (float): Face recognition tolerance threshold. Default: 0.5.\n        debug (bool): Enable debug mode. Default: False.\n        use_https (bool): Enable HTTPS. Default: False.\n        keypath (Optional[str]): Path to SSL private key file. Default: None.\n        certpath (Optional[str]): Path to SSL certificate file. Default: None.\n\n    \"\"\"\n\n    host: str = \"192.168.1.69\"\n    port: int = 8000\n    app_name: str = \"DDFR API\"\n    description: str = \"API per il riconoscimento facciale e la gestione delle persone\"\n    app_version: str = \"1.0.0\"\n    tollerance: float = 0.5\n    debug: bool = False\n    use_https: bool = False\n    keypath: Optional[str] = None\n    certpath: Optional[str] = None\n\n    class Config:\n        env_prefix = \"APP_\"\n        env_file = ENV_FILE_PATH\n        env_file_encoding = 'utf-8'\n        extra = \"ignore\"\n</code></pre>"},{"location":"models/person/","title":"Person Model","text":"<p>Person data model with validation and computed fields.</p>"},{"location":"models/person/#person-class","title":"Person Class","text":""},{"location":"models/person/#app.models.person.Person","title":"app.models.person.Person","text":"<p>               Bases: <code>BaseModel</code></p> <p>Person data model for face recognition system.</p> <p>Represents a person with personal information, face encodings, and relationship data. Uses Pydantic for validation and serialization, compatible with MongoDB ObjectId.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[PyObjectId]</code> <p>MongoDB document ID. Default: None.</p> <code>name</code> <code>str</code> <p>Person's first name. Default: \"Unknown\", length 2-50.</p> <code>surname</code> <code>str</code> <p>Person's last name. Default: \"Unknown\", length 2-50.</p> <code>birthday</code> <code>datetime</code> <p>Person's date of birth. Required, must be valid date.</p> <code>relationship</code> <code>RelationshipType</code> <p>Relationship type to the user. Default: ALTRO.</p> <code>encoding</code> <code>Optional[dict]</code> <p>Dictionary of face encodings (hash -&gt; embedding vector). Default: None.</p> <code>role</code> <code>RoleType</code> <p>Person's role in the system. Default: GUEST.</p> Source code in <code>backend/app/models/person.py</code> <pre><code>class Person(BaseModel):\n    \"\"\"Person data model for face recognition system.\n\n    Represents a person with personal information, face encodings, and relationship data.\n    Uses Pydantic for validation and serialization, compatible with MongoDB ObjectId.\n\n    Attributes:\n        id (Optional[PyObjectId]): MongoDB document ID. Default: None.\n        name (str): Person's first name. Default: \"Unknown\", length 2-50.\n        surname (str): Person's last name. Default: \"Unknown\", length 2-50.\n        birthday (datetime): Person's date of birth. Required, must be valid date.\n        relationship (RelationshipType): Relationship type to the user. Default: ALTRO.\n        encoding (Optional[dict]): Dictionary of face encodings (hash -&gt; embedding vector). Default: None.\n        role (RoleType): Person's role in the system. Default: GUEST.\n\n    \"\"\"\n\n    id: Optional[PyObjectId] = Field(alias=\"_id\", default=None)\n    name: str = Field(default=\"Unknown\", min_length=2, max_length=MAX_LENGTH)\n    surname: str = Field(default=\"Unknown\", min_length=2, max_length=MAX_LENGTH)\n\n    birthday: datetime \n\n    relationship: RelationshipType = RelationshipType.ALTRO\n    encoding: Optional[dict] = None \n    role: RoleType = RoleType.GUEST   \n\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        arbitrary_types_allowed=True \n    )\n\n\n    @field_validator('birthday') \n    @classmethod\n    def check_data_passata(cls, v: datetime) -&gt; datetime:\n        \"\"\"Validate that birthday is a valid past date.\n\n        Checks that the birthday is not in the future and not before year 1900.\n\n        Args:\n            v (datetime): The birthday datetime to validate.\n\n        Returns:\n            datetime: The validated birthday datetime.\n\n        Raises:\n            ValueError: If birthday is in the future or before year 1900.\n\n        \"\"\"\n        if v.date() &gt; date.today():\n            raise ValueError(\"La data di nascita non pu\u00f2 essere nel futuro!\")\n\n        if v.year &lt; 1900:\n            raise ValueError(\"Data di nascita non valida (troppo indietro nel tempo)\")\n\n        return v\n\n\n    @computed_field\n    def age(self) -&gt; int:\n        \"\"\"Calculate person's age based on birthday.\n\n        Computes age as the difference between current date and birthday,\n        accounting for whether the birthday has occurred this year.\n\n        Returns:\n            int: Person's age in years. Returns 0 if birthday is not set.\n\n        \"\"\"\n        today = date.today()\n        if not self.birthday:\n            return 0\n\n        return today.year - self.birthday.year - (\n            (today.month, today.day) &lt; (self.birthday.month, self.birthday.day)\n        )\n</code></pre>"},{"location":"models/person/#app.models.person.Person-functions","title":"Functions","text":""},{"location":"models/person/#app.models.person.Person.age","title":"age","text":"<pre><code>age()\n</code></pre> <p>Calculate person's age based on birthday.</p> <p>Computes age as the difference between current date and birthday, accounting for whether the birthday has occurred this year.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Person's age in years. Returns 0 if birthday is not set.</p> Source code in <code>backend/app/models/person.py</code> <pre><code>@computed_field\ndef age(self) -&gt; int:\n    \"\"\"Calculate person's age based on birthday.\n\n    Computes age as the difference between current date and birthday,\n    accounting for whether the birthday has occurred this year.\n\n    Returns:\n        int: Person's age in years. Returns 0 if birthday is not set.\n\n    \"\"\"\n    today = date.today()\n    if not self.birthday:\n        return 0\n\n    return today.year - self.birthday.year - (\n        (today.month, today.day) &lt; (self.birthday.month, self.birthday.day)\n    )\n</code></pre>"},{"location":"models/person/#app.models.person.Person.check_data_passata","title":"check_data_passata  <code>classmethod</code>","text":"<pre><code>check_data_passata(v)\n</code></pre> <p>Validate that birthday is a valid past date.</p> <p>Checks that the birthday is not in the future and not before year 1900.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>datetime</code> <p>The birthday datetime to validate.</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The validated birthday datetime.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If birthday is in the future or before year 1900.</p> Source code in <code>backend/app/models/person.py</code> <pre><code>@field_validator('birthday') \n@classmethod\ndef check_data_passata(cls, v: datetime) -&gt; datetime:\n    \"\"\"Validate that birthday is a valid past date.\n\n    Checks that the birthday is not in the future and not before year 1900.\n\n    Args:\n        v (datetime): The birthday datetime to validate.\n\n    Returns:\n        datetime: The validated birthday datetime.\n\n    Raises:\n        ValueError: If birthday is in the future or before year 1900.\n\n    \"\"\"\n    if v.date() &gt; date.today():\n        raise ValueError(\"La data di nascita non pu\u00f2 essere nel futuro!\")\n\n    if v.year &lt; 1900:\n        raise ValueError(\"Data di nascita non valida (troppo indietro nel tempo)\")\n\n    return v\n</code></pre>"},{"location":"scripts/insertdata/","title":"Insert Data Script","text":"<p>Utility script for inserting demo person data into the database.</p>"},{"location":"scripts/insertdata/#functions","title":"Functions","text":""},{"location":"scripts/insertdata/#app.insertdata._build_demo_person","title":"app.insertdata._build_demo_person","text":"<pre><code>_build_demo_person()\n</code></pre> <p>Build a demo Person instance with predefined values.</p> <p>Creates a Person object with hardcoded demo data for testing purposes.</p> <p>Returns:</p> Name Type Description <code>Person</code> <code>Person</code> <p>A Person instance with demo data (name: \"Demo\",  surname: \"User\", birthday: 2000-01-01, role: GUEST).</p> Source code in <code>backend/app/insertdata.py</code> <pre><code>def _build_demo_person() -&gt; Person:\n    \"\"\"Build a demo Person instance with predefined values.\n\n    Creates a Person object with hardcoded demo data for testing purposes.\n\n    Returns:\n        Person: A Person instance with demo data (name: \"Demo\", \n            surname: \"User\", birthday: 2000-01-01, role: GUEST).\n\n    \"\"\"\n    return Person(\n        name=\"Demo\",\n        surname=\"User\",\n        birthday=datetime(2000, 1, 1),\n        role=RoleType.GUEST,\n    )\n</code></pre>"},{"location":"scripts/insertdata/#app.insertdata.main","title":"app.insertdata.main","text":"<pre><code>main()\n</code></pre> <p>Main function to insert demo person data into the database.</p> <p>Analyzes all images in the configured images folder, extracts face encodings, and inserts a demo person with the collected encodings into the database. Logs errors if no valid encodings are found or if database insertion fails.</p> Source code in <code>backend/app/insertdata.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Main function to insert demo person data into the database.\n\n    Analyzes all images in the configured images folder, extracts face encodings,\n    and inserts a demo person with the collected encodings into the database.\n    Logs errors if no valid encodings are found or if database insertion fails.\n\n    \"\"\"\n    dataset = database.Database(\n        url=set.url,\n        name=set.name,\n        collection=set.collection,\n    )\n    people = dataset.get_all_people() \n    engine = FaceEngine(people)   \n    demo_person = _build_demo_person()\n\n    all_encodings = {} \n    folder = Path(path_settings.imgsfolder)\n\n    for elemento in folder.iterdir():\n        if elemento.is_file() and not elemento.name.startswith('.'):\n            print(f\"Analisi di: {elemento.name}...\")\n            new_data = engine.analyze_img(elemento)\n\n            if new_data is not None:\n                all_encodings.update(new_data) \n                print(f\" -&gt; OK, volto trovato.\")\n            else:\n                print(f\" -&gt; Nessun volto trovato o file non valido.\")\n\n    if not all_encodings:\n        logger.error(\"Nessun encoding valido generato da nessuna foto.\")\n        return\n\n    demo_person.encoding = all_encodings\n    saved = dataset.add_person(demo_person)\n\n    if saved is not None:\n        logger.info(f\"Inserimento completato. ID: {saved.id} - Totale foto: {len(all_encodings)}\")\n        print(\"Inserimento completato.\")\n    else:\n        logger.error(\"Inserimento fallito da parte del Database.\")\n        print(\"Inserimento fallito.\")\n</code></pre>"},{"location":"services/database/","title":"Database Service","text":"<p>MongoDB database service for person data management.</p>"},{"location":"services/database/#database-class","title":"Database Class","text":""},{"location":"services/database/#app.services.database.Database","title":"app.services.database.Database","text":"<p>MongoDB database service for person data management.</p> <p>Manages connections to MongoDB, handles CRUD operations for Person objects, and maintains a cached reference to the user/patient (role=USER) person.</p> <p>Attributes:</p> Name Type Description <code>current_client</code> <code>Optional[MongoClient]</code> <p>Class-level MongoDB client instance.</p> <code>url</code> <code>str</code> <p>MongoDB connection URL.</p> <code>name_db</code> <code>str</code> <p>Database name.</p> <code>collection_name</code> <code>str</code> <p>Collection name within the database.</p> <code>patient</code> <code>Optional[Person]</code> <p>Cached reference to the user/patient person.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>class Database():\n    \"\"\"MongoDB database service for person data management.\n\n    Manages connections to MongoDB, handles CRUD operations for Person objects,\n    and maintains a cached reference to the user/patient (role=USER) person.\n\n    Attributes:\n        current_client (Optional[pymongo.MongoClient]): Class-level MongoDB client instance.\n        url (str): MongoDB connection URL.\n        name_db (str): Database name.\n        collection_name (str): Collection name within the database.\n        patient (Optional[Person]): Cached reference to the user/patient person.\n\n    \"\"\"\n\n    current_client = None \n\n    def __init__(self, url: str, name: str, collection: str):\n        \"\"\"Initialize Database instance and establish connection.\n\n        Args:\n            url (str): MongoDB connection URL.\n            name (str): Database name.\n            collection (str): Collection name.\n\n        Raises:\n            ConnectionFailure: If connection to MongoDB fails.\n            ValueError: If connection URL conflicts with existing connection.\n\n        \"\"\"\n        self.url = url\n        self.name_db = name\n        self.collection_name = collection\n        self.get_connection(self.url)\n        self.patient: Optional[Person] = None\n        self.patient = self.check_patient_existence()\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if database connection is active.\n\n        Returns:\n            bool: True if connection is active and responsive, False otherwise.\n\n        \"\"\"\n        if self.current_client is None:\n            return False\n        try:\n            self.current_client.admin.command('ping')\n            return True      \n        except (ConnectionFailure, ServerSelectionTimeoutError):\n            return False\n\n    def check_patient_existence(self) -&gt; Optional[Person] | None:\n        \"\"\"Check if a patient (role=USER) exists in the database.\n\n        Returns cached patient if available, otherwise queries the database.\n\n        Returns:\n            Optional[Person]: Patient person if found, None otherwise.\n\n        \"\"\"\n        cached_patient: Optional[Person] = getattr(self, \"patient\", None)\n        if cached_patient is not None:\n            return cached_patient\n\n        collection = self.get_collection()\n        query = {\"role\": RoleType.USER.value}\n        doc = collection.find_one(query)\n        patient = self._person_from_doc(doc)\n        if patient:\n            self.patient = patient\n        return patient\n\n    @classmethod\n    def get_connection(cls, url: str) -&gt; pymongo.MongoClient | None:\n        \"\"\"Get or create MongoDB client connection.\n\n        Creates a new connection if none exists, or validates existing connection.\n        Uses singleton pattern to share connection across instances.\n\n        Args:\n            url (str): MongoDB connection URL.\n\n        Returns:\n            pymongo.MongoClient | None: MongoDB client instance, or None if URL is invalid.\n\n        Raises:\n            ConnectionFailure: If connection fails.\n            ConfigurationError: If connection configuration is invalid.\n            ValueError: If URL conflicts with existing connection.\n\n        \"\"\"\n        if url is None:\n            logger.error(\"URL di connessione non fornito.\")\n            return None\n\n        if cls.current_client is None:\n            try:\n                cls.current_client = pymongo.MongoClient(url)\n                cls.current_client.admin.command('ping')\n            except (pymongo.errors.ConnectionFailure, pymongo.errors.ConfigurationError) as e:\n                logger.critical(f\"Errore critico di connessione al database: {e}\")\n                cls.current_client = None\n                raise\n        else:\n            try:\n                parsed_uri = parse_uri(url)\n                new_nodes = set(parsed_uri['nodelist'])\n                current_node = cls.current_client.address \n\n                if current_node and current_node not in new_nodes:\n                    error_msg = (\n                        f\"Connessione gi\u00e0 esistente con un host diverso.\\n\"\n                        f\"Attivo: {current_node}\\n\"\n                        f\"Richiesto: {new_nodes} (da {url})\"\n                    )\n                    logger.warning(error_msg)\n                    raise ValueError(error_msg)\n            except Exception as e:\n                logger.error(f\"Errore durante la verifica dell'URL esistente: {e}\")\n\n        return cls.current_client\n\n    @classmethod\n    def close_connection(cls):\n        \"\"\"Close MongoDB connection and reset client.\n\n        Closes the shared MongoDB client connection and sets it to None.\n\n        \"\"\"\n        if cls.current_client is not None:\n            cls.current_client.close()\n            cls.current_client = None\n\n    @staticmethod\n    def convert_to_objectid(id_string: str) -&gt; Optional[ObjectId]:\n        \"\"\"Convert string ID to MongoDB ObjectId.\n\n        Args:\n            id_string (str): String representation of MongoDB ObjectId.\n\n        Returns:\n            Optional[ObjectId]: ObjectId if valid, None otherwise.\n\n        \"\"\"\n        if id_string is None:\n             return None\n        try:\n            return ObjectId(id_string)\n        except (errors.InvalidId, TypeError):\n            logger.error(f\"ID non valido per ObjectId: {id_string}\")\n            return None\n\n    @staticmethod\n    def _person_to_document(person: Person) -&gt; dict:\n        \"\"\"Convert Person object to MongoDB document format.\n\n        Serializes Person to dictionary, handling dates, enums, and numpy arrays\n        in encoding dictionaries for MongoDB storage.\n\n        Args:\n            person (Person): Person object to serialize.\n\n        Returns:\n            dict: Dictionary ready for MongoDB insertion/update.\n\n        \"\"\"\n        # Serializza Person per Mongo, gestendo date ed Enums\n        person_dict = person.model_dump(by_alias=True, exclude_none=True)\n\n        if person_dict.get(\"_id\") is None:\n            person_dict.pop(\"_id\", None)\n\n        if \"birthday\" in person_dict:\n            b_day = person_dict[\"birthday\"]\n            if type(b_day) == date:\n                person_dict[\"birthday\"] = datetime(b_day.year, b_day.month, b_day.day)\n\n        if \"encoding\" in person_dict and person_dict[\"encoding\"] is not None:\n            encoding_dict = person_dict[\"encoding\"]\n            if isinstance(encoding_dict, dict):\n                serialized_encoding = {}\n                for hash_key, encoding_value in encoding_dict.items():\n                    if isinstance(encoding_value, np.ndarray):\n                        serialized_encoding[hash_key] = encoding_value.tolist()\n                    elif isinstance(encoding_value, list):\n                        serialized_encoding[hash_key] = [float(x) for x in encoding_value]\n                    else:\n                        serialized_encoding[hash_key] = encoding_value\n                person_dict[\"encoding\"] = serialized_encoding\n\n        for key, value in person_dict.items():\n            if hasattr(value, \"value\"):  \n                person_dict[key] = value.value\n\n        return person_dict\n\n    @staticmethod\n    def _person_from_doc(doc: Optional[dict]) -&gt; Optional[Person]:\n        \"\"\"Convert MongoDB document to Person object.\n\n        Args:\n            doc (Optional[dict]): MongoDB document dictionary.\n\n        Returns:\n            Optional[Person]: Person object if valid, None otherwise.\n\n        \"\"\"\n        if doc is None:\n            return None\n        try:\n            return Person.model_validate(doc)\n        except Exception as exc:\n            logger.error(f\"Documento Person non valido: {exc}\")\n            return None\n\n    def get_collection(self) -&gt; pymongo.collection.Collection | None:\n        \"\"\"Get MongoDB collection instance.\n\n        Returns:\n            pymongo.collection.Collection | None: MongoDB collection instance, or None if connection fails.\n\n        \"\"\"\n        client = None\n        try :\n            client = self.get_connection(self.url)\n        except Exception as e:\n            logger.critical(f\"Impossibile collegarsi al database per ottenere la collezione: {e}\")\n            return None\n\n        if client is None:\n            return None\n\n        db = client[self.name_db] \n        return db[self.collection_name]\n\n    def add_person(self, person: Person) -&gt; Optional[Person] | None:\n        \"\"\"Add a new person to the database.\n\n        Inserts person document into MongoDB. Ensures only one USER role person exists.\n        Updates person.id with the inserted document ID.\n\n        Args:\n            person (Person): Person object to insert.\n\n        Returns:\n            Optional[Person]: Person object with assigned ID if successful, None otherwise.\n\n        Raises:\n            DuplicateKeyError: If duplicate key constraint violation occurs.\n            WriteConcernError: If write operation fails.\n            ConnectionFailure: If database connection is lost.\n\n        \"\"\"\n        collection = self.get_collection()\n        person_dict = self._person_to_document(person)\n\n        if person.role == RoleType.USER:\n            if getattr(self, \"patient\", None) is not None:\n                logger.error(\"Impossibile inserire. Esiste gi\u00e0 un paziente registrato.\")\n                return None\n        try:\n            result = collection.insert_one(person_dict)\n            person.id = str(result.inserted_id)\n            if person.role == RoleType.USER:\n                self.patient = person  \n            return person\n\n        except DuplicateKeyError as e:\n            logger.error(f\"Impossibile inserire. Chiave duplicata rilevata: {e}\")\n            self._rollback_user_slot(person)\n            return None\n\n        except WriteConcernError as e:\n            logger.critical(f\"Errore di scrittura: {e}\")\n            self._rollback_user_slot(person)\n            return None\n\n        except ConnectionFailure as e:\n            logger.critical(f\"ERRORE DI CONNESSIONE: Il database non \u00e8 raggiungibile: {e}\")\n            self._rollback_user_slot(person)\n            return None\n\n        except Exception as e:\n            logger.error(f\"Errore sconosciuto durante l'inserimento: {e}\")\n            self._rollback_user_slot(person)\n            return None\n\n    @staticmethod\n    def _rollback_user_slot(person: Person):\n        \"\"\"Reset user slot if person role is USER.\n\n        Args:\n            person (Person): Person object to check for USER role.\n\n        \"\"\"\n        if person.role == RoleType.USER:\n            Person.reset_user_slot()      \n\n    def remove_person(self, person_id: str) -&gt; bool:\n        \"\"\"Remove a person from the database by ID.\n\n        \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n        Consider implementing proper deletion endpoints if needed.\n\n        Args:\n            person_id (str): Person's MongoDB ObjectId as string.\n\n        Returns:\n            bool: True if person was deleted, False otherwise.\n\n        \"\"\"\n        collection = self.get_collection()\n\n        oid = Database.convert_to_objectid(person_id)\n        if oid is None:\n            logger.warning(f\"ID non valido per la rimozione: {person_id}\")\n            return False\n\n        result = collection.delete_one({\"_id\": oid})\n\n        if result.deleted_count &gt; 0:\n            cached_patient: Optional[Person] = getattr(self, \"patient\", None)\n            if cached_patient is not None and str(cached_patient.id) == person_id:\n                self.patient = None\n            return True\n        else:\n            logger.warning(f\"Nessuna persona trovata con ID {person_id}.\")\n            return False\n\n    def get_all_people(self) -&gt; list[Person]:\n        \"\"\"Retrieve all people from the database.\n\n        Uses projection to load only necessary fields for performance optimization.\n\n        Returns:\n            list[Person]: List of all Person objects in the database.\n\n        \"\"\"\n        collection = self.get_collection()\n        # Projection: carica solo i campi necessari per ottimizzare prestazioni\n        projection = {\n            \"_id\": 1,\n            \"name\": 1,\n            \"surname\": 1,\n            \"encoding\": 1,\n            \"role\": 1,\n            \"relationship\": 1,\n            \"birthday\": 1\n        }\n        cursor = collection.find({}, projection)\n        people: list[Person] = []\n        for doc in cursor:\n            person = self._person_from_doc(doc)\n            if person is not None:\n                people.append(person)\n        return people\n\n    def get_person(self, person_id: str) -&gt; Optional[Person]:\n        \"\"\"Retrieve a person by ID.\n\n        \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n        The application primarily works with `get_all_people()` to load all persons\n        for face recognition. Consider implementing REST API endpoints if individual\n        person retrieval is needed.\n\n        Args:\n            person_id (str): Person's MongoDB ObjectId as string.\n\n        Returns:\n            Optional[Person]: Person object if found, None otherwise.\n\n        \"\"\"\n        collection = self.get_collection()\n        oid = Database.convert_to_objectid(person_id)\n        if oid is None:\n            logger.warning(f\"ID non valido per il recupero dei dati: {person_id}\")\n            return None\n        doc = collection.find_one({\"_id\": oid})\n        return self._person_from_doc(doc)\n\n    def update_person(self, person_id: str, update_data: Person | dict) -&gt; Optional[Person]:\n        \"\"\"Update a person's data in the database.\n\n        \u26a0\ufe0f **Deprecated**: This method is only used internally by `update_people()` which\n        itself is not used. Consider implementing REST API endpoints for person updates\n        if needed.\n\n        Args:\n            person_id (str): Person's MongoDB ObjectId as string.\n            update_data (Person | dict): Person object or dictionary with update fields.\n\n        Returns:\n            Optional[Person]: Updated Person object if successful, None otherwise.\n\n        \"\"\"\n        collection = self.get_collection()\n\n        oid = Database.convert_to_objectid(person_id)\n        if oid is None:\n            logger.warning(f\"ID non valido per aggiornamento: {person_id}\")\n            return None\n\n\n        if person_id != str(oid):\n            logger.warning(f\"ID non coerente per aggiornamento: {person_id} vs {str(oid)}\")\n            return None\n\n        if isinstance(update_data, Person):\n            payload = self._person_to_document(update_data)\n        else:\n            payload = dict(update_data)\n\n        payload.pop(\"_id\", None)\n        payload.pop(\"id\", None)\n\n        if not payload:\n            logger.warning(\"Nessun dato valido fornito per l'aggiornamento.\")\n            return None\n\n        updated_doc = collection.find_one_and_update(\n            {\"_id\": oid},\n            {\"$set\": payload},\n            return_document=ReturnDocument.AFTER\n        )\n\n        if updated_doc:\n            person = self._person_from_doc(updated_doc)\n            return person\n\n        logger.warning(f\"Nessuna persona trovata con ID {person_id} per l'aggiornamento.\")\n        return None\n\n    def update_people(self, people: list) -&gt; int:\n        \"\"\"Update multiple people in the database.\n\n        \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n        Person management is primarily done through `add_person()` during initial setup.\n        Consider implementing batch update functionality via REST API if needed.\n\n        Adds new people (id=None) or updates existing ones based on their ID.\n\n        Args:\n            people (list): List of Person objects to add or update.\n\n        Returns:\n            int: Number of successfully processed people.\n\n        \"\"\"\n        success_count = 0\n        for person in people:\n            p = None\n\n            if person.id is None:\n                p = self.add_person(person)                  \n            elif person.id is not None:\n                p = self.update_person(person.id, person)\n            else:\n                logger.error(f\"Impossibile aggiornare persona con dati: {person}\")\n\n            if p is not None:\n                    success_count += 1\n\n        return success_count\n\n    def get_all_encodings(self) -&gt; tuple[list[str], list[np.ndarray]]:\n        \"\"\"Extract all face encodings from all people in the database.\n\n        \u26a0\ufe0f **Deprecated**: This method was used with the old `face_recognition` library.\n        The current implementation uses `FaceEngine` which directly processes Person objects\n        with encodings stored in the `encoding` field. Use `get_all_people()` instead and\n        access encodings directly from Person objects.\n\n        Returns:\n            tuple[list[str], list[np.ndarray]]: (known_ids, known_encodings) where known_ids is a list of person IDs\n                and known_encodings is a list of numpy arrays representing face embeddings.\n\n        \"\"\"\n        people = self.get_all_people()\n\n        known_encodings = []\n        known_ids = []\n\n        for person in people:\n            id = person.id\n\n            face_encodings_dict = person.encoding or {}\n            if not face_encodings_dict:\n                logger.warning(f\"{id} risulta vuoto\")\n                continue\n\n            for hash_key, encoding_list in face_encodings_dict.items():\n                try: \n                    known_encodings.append(np.array(encoding_list))\n                    known_ids.append(id)\n                except Exception as e:\n                    logger.error(f\"Saltato encoding corrotto per {str(id)} (Hash: {hash_key}). Causa: {e}\")\n                    continue\n\n        return known_ids, known_encodings\n\n    def drop_database(self):\n        \"\"\"Drop the entire database and close connection.\n\n        \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n        Reserved for testing and maintenance purposes. Use with extreme caution\n        as it permanently deletes all data.\n\n        Permanently deletes the database and all its collections.\n        Resets patient cache and closes connection.\n\n        \"\"\"\n        client = self.get_connection(self.url)\n        client.drop_database(self.name_db) \n        if hasattr(self, \"patient\"):\n            self.patient = None\n        self.close_connection()\n</code></pre>"},{"location":"services/database/#app.services.database.Database-attributes","title":"Attributes","text":""},{"location":"services/database/#app.services.database.Database.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected\n</code></pre> <p>Check if database connection is active.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connection is active and responsive, False otherwise.</p>"},{"location":"services/database/#app.services.database.Database-functions","title":"Functions","text":""},{"location":"services/database/#app.services.database.Database.__init__","title":"__init__","text":"<pre><code>__init__(url, name, collection)\n</code></pre> <p>Initialize Database instance and establish connection.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>MongoDB connection URL.</p> required <code>name</code> <code>str</code> <p>Database name.</p> required <code>collection</code> <code>str</code> <p>Collection name.</p> required <p>Raises:</p> Type Description <code>ConnectionFailure</code> <p>If connection to MongoDB fails.</p> <code>ValueError</code> <p>If connection URL conflicts with existing connection.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def __init__(self, url: str, name: str, collection: str):\n    \"\"\"Initialize Database instance and establish connection.\n\n    Args:\n        url (str): MongoDB connection URL.\n        name (str): Database name.\n        collection (str): Collection name.\n\n    Raises:\n        ConnectionFailure: If connection to MongoDB fails.\n        ValueError: If connection URL conflicts with existing connection.\n\n    \"\"\"\n    self.url = url\n    self.name_db = name\n    self.collection_name = collection\n    self.get_connection(self.url)\n    self.patient: Optional[Person] = None\n    self.patient = self.check_patient_existence()\n</code></pre>"},{"location":"services/database/#app.services.database.Database.add_person","title":"add_person","text":"<pre><code>add_person(person)\n</code></pre> <p>Add a new person to the database.</p> <p>Inserts person document into MongoDB. Ensures only one USER role person exists. Updates person.id with the inserted document ID.</p> <p>Parameters:</p> Name Type Description Default <code>person</code> <code>Person</code> <p>Person object to insert.</p> required <p>Returns:</p> Type Description <code>Optional[Person] | None</code> <p>Optional[Person]: Person object with assigned ID if successful, None otherwise.</p> <p>Raises:</p> Type Description <code>DuplicateKeyError</code> <p>If duplicate key constraint violation occurs.</p> <code>WriteConcernError</code> <p>If write operation fails.</p> <code>ConnectionFailure</code> <p>If database connection is lost.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def add_person(self, person: Person) -&gt; Optional[Person] | None:\n    \"\"\"Add a new person to the database.\n\n    Inserts person document into MongoDB. Ensures only one USER role person exists.\n    Updates person.id with the inserted document ID.\n\n    Args:\n        person (Person): Person object to insert.\n\n    Returns:\n        Optional[Person]: Person object with assigned ID if successful, None otherwise.\n\n    Raises:\n        DuplicateKeyError: If duplicate key constraint violation occurs.\n        WriteConcernError: If write operation fails.\n        ConnectionFailure: If database connection is lost.\n\n    \"\"\"\n    collection = self.get_collection()\n    person_dict = self._person_to_document(person)\n\n    if person.role == RoleType.USER:\n        if getattr(self, \"patient\", None) is not None:\n            logger.error(\"Impossibile inserire. Esiste gi\u00e0 un paziente registrato.\")\n            return None\n    try:\n        result = collection.insert_one(person_dict)\n        person.id = str(result.inserted_id)\n        if person.role == RoleType.USER:\n            self.patient = person  \n        return person\n\n    except DuplicateKeyError as e:\n        logger.error(f\"Impossibile inserire. Chiave duplicata rilevata: {e}\")\n        self._rollback_user_slot(person)\n        return None\n\n    except WriteConcernError as e:\n        logger.critical(f\"Errore di scrittura: {e}\")\n        self._rollback_user_slot(person)\n        return None\n\n    except ConnectionFailure as e:\n        logger.critical(f\"ERRORE DI CONNESSIONE: Il database non \u00e8 raggiungibile: {e}\")\n        self._rollback_user_slot(person)\n        return None\n\n    except Exception as e:\n        logger.error(f\"Errore sconosciuto durante l'inserimento: {e}\")\n        self._rollback_user_slot(person)\n        return None\n</code></pre>"},{"location":"services/database/#app.services.database.Database.check_patient_existence","title":"check_patient_existence","text":"<pre><code>check_patient_existence()\n</code></pre> <p>Check if a patient (role=USER) exists in the database.</p> <p>Returns cached patient if available, otherwise queries the database.</p> <p>Returns:</p> Type Description <code>Optional[Person] | None</code> <p>Optional[Person]: Patient person if found, None otherwise.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def check_patient_existence(self) -&gt; Optional[Person] | None:\n    \"\"\"Check if a patient (role=USER) exists in the database.\n\n    Returns cached patient if available, otherwise queries the database.\n\n    Returns:\n        Optional[Person]: Patient person if found, None otherwise.\n\n    \"\"\"\n    cached_patient: Optional[Person] = getattr(self, \"patient\", None)\n    if cached_patient is not None:\n        return cached_patient\n\n    collection = self.get_collection()\n    query = {\"role\": RoleType.USER.value}\n    doc = collection.find_one(query)\n    patient = self._person_from_doc(doc)\n    if patient:\n        self.patient = patient\n    return patient\n</code></pre>"},{"location":"services/database/#app.services.database.Database.close_connection","title":"close_connection  <code>classmethod</code>","text":"<pre><code>close_connection()\n</code></pre> <p>Close MongoDB connection and reset client.</p> <p>Closes the shared MongoDB client connection and sets it to None.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>@classmethod\ndef close_connection(cls):\n    \"\"\"Close MongoDB connection and reset client.\n\n    Closes the shared MongoDB client connection and sets it to None.\n\n    \"\"\"\n    if cls.current_client is not None:\n        cls.current_client.close()\n        cls.current_client = None\n</code></pre>"},{"location":"services/database/#app.services.database.Database.convert_to_objectid","title":"convert_to_objectid  <code>staticmethod</code>","text":"<pre><code>convert_to_objectid(id_string)\n</code></pre> <p>Convert string ID to MongoDB ObjectId.</p> <p>Parameters:</p> Name Type Description Default <code>id_string</code> <code>str</code> <p>String representation of MongoDB ObjectId.</p> required <p>Returns:</p> Type Description <code>Optional[ObjectId]</code> <p>Optional[ObjectId]: ObjectId if valid, None otherwise.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>@staticmethod\ndef convert_to_objectid(id_string: str) -&gt; Optional[ObjectId]:\n    \"\"\"Convert string ID to MongoDB ObjectId.\n\n    Args:\n        id_string (str): String representation of MongoDB ObjectId.\n\n    Returns:\n        Optional[ObjectId]: ObjectId if valid, None otherwise.\n\n    \"\"\"\n    if id_string is None:\n         return None\n    try:\n        return ObjectId(id_string)\n    except (errors.InvalidId, TypeError):\n        logger.error(f\"ID non valido per ObjectId: {id_string}\")\n        return None\n</code></pre>"},{"location":"services/database/#app.services.database.Database.drop_database","title":"drop_database","text":"<pre><code>drop_database()\n</code></pre> <p>Drop the entire database and close connection.</p> <p>\u26a0\ufe0f Deprecated: This method is not currently used in the application. Reserved for testing and maintenance purposes. Use with extreme caution as it permanently deletes all data.</p> <p>Permanently deletes the database and all its collections. Resets patient cache and closes connection.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def drop_database(self):\n    \"\"\"Drop the entire database and close connection.\n\n    \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n    Reserved for testing and maintenance purposes. Use with extreme caution\n    as it permanently deletes all data.\n\n    Permanently deletes the database and all its collections.\n    Resets patient cache and closes connection.\n\n    \"\"\"\n    client = self.get_connection(self.url)\n    client.drop_database(self.name_db) \n    if hasattr(self, \"patient\"):\n        self.patient = None\n    self.close_connection()\n</code></pre>"},{"location":"services/database/#app.services.database.Database.get_all_encodings","title":"get_all_encodings","text":"<pre><code>get_all_encodings()\n</code></pre> <p>Extract all face encodings from all people in the database.</p> <p>\u26a0\ufe0f Deprecated: This method was used with the old <code>face_recognition</code> library. The current implementation uses <code>FaceEngine</code> which directly processes Person objects with encodings stored in the <code>encoding</code> field. Use <code>get_all_people()</code> instead and access encodings directly from Person objects.</p> <p>Returns:</p> Type Description <code>tuple[list[str], list[ndarray]]</code> <p>tuple[list[str], list[np.ndarray]]: (known_ids, known_encodings) where known_ids is a list of person IDs and known_encodings is a list of numpy arrays representing face embeddings.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def get_all_encodings(self) -&gt; tuple[list[str], list[np.ndarray]]:\n    \"\"\"Extract all face encodings from all people in the database.\n\n    \u26a0\ufe0f **Deprecated**: This method was used with the old `face_recognition` library.\n    The current implementation uses `FaceEngine` which directly processes Person objects\n    with encodings stored in the `encoding` field. Use `get_all_people()` instead and\n    access encodings directly from Person objects.\n\n    Returns:\n        tuple[list[str], list[np.ndarray]]: (known_ids, known_encodings) where known_ids is a list of person IDs\n            and known_encodings is a list of numpy arrays representing face embeddings.\n\n    \"\"\"\n    people = self.get_all_people()\n\n    known_encodings = []\n    known_ids = []\n\n    for person in people:\n        id = person.id\n\n        face_encodings_dict = person.encoding or {}\n        if not face_encodings_dict:\n            logger.warning(f\"{id} risulta vuoto\")\n            continue\n\n        for hash_key, encoding_list in face_encodings_dict.items():\n            try: \n                known_encodings.append(np.array(encoding_list))\n                known_ids.append(id)\n            except Exception as e:\n                logger.error(f\"Saltato encoding corrotto per {str(id)} (Hash: {hash_key}). Causa: {e}\")\n                continue\n\n    return known_ids, known_encodings\n</code></pre>"},{"location":"services/database/#app.services.database.Database.get_all_people","title":"get_all_people","text":"<pre><code>get_all_people()\n</code></pre> <p>Retrieve all people from the database.</p> <p>Uses projection to load only necessary fields for performance optimization.</p> <p>Returns:</p> Type Description <code>list[Person]</code> <p>list[Person]: List of all Person objects in the database.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def get_all_people(self) -&gt; list[Person]:\n    \"\"\"Retrieve all people from the database.\n\n    Uses projection to load only necessary fields for performance optimization.\n\n    Returns:\n        list[Person]: List of all Person objects in the database.\n\n    \"\"\"\n    collection = self.get_collection()\n    # Projection: carica solo i campi necessari per ottimizzare prestazioni\n    projection = {\n        \"_id\": 1,\n        \"name\": 1,\n        \"surname\": 1,\n        \"encoding\": 1,\n        \"role\": 1,\n        \"relationship\": 1,\n        \"birthday\": 1\n    }\n    cursor = collection.find({}, projection)\n    people: list[Person] = []\n    for doc in cursor:\n        person = self._person_from_doc(doc)\n        if person is not None:\n            people.append(person)\n    return people\n</code></pre>"},{"location":"services/database/#app.services.database.Database.get_collection","title":"get_collection","text":"<pre><code>get_collection()\n</code></pre> <p>Get MongoDB collection instance.</p> <p>Returns:</p> Type Description <code>Collection | None</code> <p>pymongo.collection.Collection | None: MongoDB collection instance, or None if connection fails.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def get_collection(self) -&gt; pymongo.collection.Collection | None:\n    \"\"\"Get MongoDB collection instance.\n\n    Returns:\n        pymongo.collection.Collection | None: MongoDB collection instance, or None if connection fails.\n\n    \"\"\"\n    client = None\n    try :\n        client = self.get_connection(self.url)\n    except Exception as e:\n        logger.critical(f\"Impossibile collegarsi al database per ottenere la collezione: {e}\")\n        return None\n\n    if client is None:\n        return None\n\n    db = client[self.name_db] \n    return db[self.collection_name]\n</code></pre>"},{"location":"services/database/#app.services.database.Database.get_connection","title":"get_connection  <code>classmethod</code>","text":"<pre><code>get_connection(url)\n</code></pre> <p>Get or create MongoDB client connection.</p> <p>Creates a new connection if none exists, or validates existing connection. Uses singleton pattern to share connection across instances.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>MongoDB connection URL.</p> required <p>Returns:</p> Type Description <code>MongoClient | None</code> <p>pymongo.MongoClient | None: MongoDB client instance, or None if URL is invalid.</p> <p>Raises:</p> Type Description <code>ConnectionFailure</code> <p>If connection fails.</p> <code>ConfigurationError</code> <p>If connection configuration is invalid.</p> <code>ValueError</code> <p>If URL conflicts with existing connection.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>@classmethod\ndef get_connection(cls, url: str) -&gt; pymongo.MongoClient | None:\n    \"\"\"Get or create MongoDB client connection.\n\n    Creates a new connection if none exists, or validates existing connection.\n    Uses singleton pattern to share connection across instances.\n\n    Args:\n        url (str): MongoDB connection URL.\n\n    Returns:\n        pymongo.MongoClient | None: MongoDB client instance, or None if URL is invalid.\n\n    Raises:\n        ConnectionFailure: If connection fails.\n        ConfigurationError: If connection configuration is invalid.\n        ValueError: If URL conflicts with existing connection.\n\n    \"\"\"\n    if url is None:\n        logger.error(\"URL di connessione non fornito.\")\n        return None\n\n    if cls.current_client is None:\n        try:\n            cls.current_client = pymongo.MongoClient(url)\n            cls.current_client.admin.command('ping')\n        except (pymongo.errors.ConnectionFailure, pymongo.errors.ConfigurationError) as e:\n            logger.critical(f\"Errore critico di connessione al database: {e}\")\n            cls.current_client = None\n            raise\n    else:\n        try:\n            parsed_uri = parse_uri(url)\n            new_nodes = set(parsed_uri['nodelist'])\n            current_node = cls.current_client.address \n\n            if current_node and current_node not in new_nodes:\n                error_msg = (\n                    f\"Connessione gi\u00e0 esistente con un host diverso.\\n\"\n                    f\"Attivo: {current_node}\\n\"\n                    f\"Richiesto: {new_nodes} (da {url})\"\n                )\n                logger.warning(error_msg)\n                raise ValueError(error_msg)\n        except Exception as e:\n            logger.error(f\"Errore durante la verifica dell'URL esistente: {e}\")\n\n    return cls.current_client\n</code></pre>"},{"location":"services/database/#app.services.database.Database.get_person","title":"get_person","text":"<pre><code>get_person(person_id)\n</code></pre> <p>Retrieve a person by ID.</p> <p>\u26a0\ufe0f Deprecated: This method is not currently used in the application. The application primarily works with <code>get_all_people()</code> to load all persons for face recognition. Consider implementing REST API endpoints if individual person retrieval is needed.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>str</code> <p>Person's MongoDB ObjectId as string.</p> required <p>Returns:</p> Type Description <code>Optional[Person]</code> <p>Optional[Person]: Person object if found, None otherwise.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def get_person(self, person_id: str) -&gt; Optional[Person]:\n    \"\"\"Retrieve a person by ID.\n\n    \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n    The application primarily works with `get_all_people()` to load all persons\n    for face recognition. Consider implementing REST API endpoints if individual\n    person retrieval is needed.\n\n    Args:\n        person_id (str): Person's MongoDB ObjectId as string.\n\n    Returns:\n        Optional[Person]: Person object if found, None otherwise.\n\n    \"\"\"\n    collection = self.get_collection()\n    oid = Database.convert_to_objectid(person_id)\n    if oid is None:\n        logger.warning(f\"ID non valido per il recupero dei dati: {person_id}\")\n        return None\n    doc = collection.find_one({\"_id\": oid})\n    return self._person_from_doc(doc)\n</code></pre>"},{"location":"services/database/#app.services.database.Database.remove_person","title":"remove_person","text":"<pre><code>remove_person(person_id)\n</code></pre> <p>Remove a person from the database by ID.</p> <p>\u26a0\ufe0f Deprecated: This method is not currently used in the application. Consider implementing proper deletion endpoints if needed.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>str</code> <p>Person's MongoDB ObjectId as string.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if person was deleted, False otherwise.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def remove_person(self, person_id: str) -&gt; bool:\n    \"\"\"Remove a person from the database by ID.\n\n    \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n    Consider implementing proper deletion endpoints if needed.\n\n    Args:\n        person_id (str): Person's MongoDB ObjectId as string.\n\n    Returns:\n        bool: True if person was deleted, False otherwise.\n\n    \"\"\"\n    collection = self.get_collection()\n\n    oid = Database.convert_to_objectid(person_id)\n    if oid is None:\n        logger.warning(f\"ID non valido per la rimozione: {person_id}\")\n        return False\n\n    result = collection.delete_one({\"_id\": oid})\n\n    if result.deleted_count &gt; 0:\n        cached_patient: Optional[Person] = getattr(self, \"patient\", None)\n        if cached_patient is not None and str(cached_patient.id) == person_id:\n            self.patient = None\n        return True\n    else:\n        logger.warning(f\"Nessuna persona trovata con ID {person_id}.\")\n        return False\n</code></pre>"},{"location":"services/database/#app.services.database.Database.update_people","title":"update_people","text":"<pre><code>update_people(people)\n</code></pre> <p>Update multiple people in the database.</p> <p>\u26a0\ufe0f Deprecated: This method is not currently used in the application. Person management is primarily done through <code>add_person()</code> during initial setup. Consider implementing batch update functionality via REST API if needed.</p> <p>Adds new people (id=None) or updates existing ones based on their ID.</p> <p>Parameters:</p> Name Type Description Default <code>people</code> <code>list</code> <p>List of Person objects to add or update.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of successfully processed people.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def update_people(self, people: list) -&gt; int:\n    \"\"\"Update multiple people in the database.\n\n    \u26a0\ufe0f **Deprecated**: This method is not currently used in the application.\n    Person management is primarily done through `add_person()` during initial setup.\n    Consider implementing batch update functionality via REST API if needed.\n\n    Adds new people (id=None) or updates existing ones based on their ID.\n\n    Args:\n        people (list): List of Person objects to add or update.\n\n    Returns:\n        int: Number of successfully processed people.\n\n    \"\"\"\n    success_count = 0\n    for person in people:\n        p = None\n\n        if person.id is None:\n            p = self.add_person(person)                  \n        elif person.id is not None:\n            p = self.update_person(person.id, person)\n        else:\n            logger.error(f\"Impossibile aggiornare persona con dati: {person}\")\n\n        if p is not None:\n                success_count += 1\n\n    return success_count\n</code></pre>"},{"location":"services/database/#app.services.database.Database.update_person","title":"update_person","text":"<pre><code>update_person(person_id, update_data)\n</code></pre> <p>Update a person's data in the database.</p> <p>\u26a0\ufe0f Deprecated: This method is only used internally by <code>update_people()</code> which itself is not used. Consider implementing REST API endpoints for person updates if needed.</p> <p>Parameters:</p> Name Type Description Default <code>person_id</code> <code>str</code> <p>Person's MongoDB ObjectId as string.</p> required <code>update_data</code> <code>Person | dict</code> <p>Person object or dictionary with update fields.</p> required <p>Returns:</p> Type Description <code>Optional[Person]</code> <p>Optional[Person]: Updated Person object if successful, None otherwise.</p> Source code in <code>backend/app/services/database.py</code> <pre><code>def update_person(self, person_id: str, update_data: Person | dict) -&gt; Optional[Person]:\n    \"\"\"Update a person's data in the database.\n\n    \u26a0\ufe0f **Deprecated**: This method is only used internally by `update_people()` which\n    itself is not used. Consider implementing REST API endpoints for person updates\n    if needed.\n\n    Args:\n        person_id (str): Person's MongoDB ObjectId as string.\n        update_data (Person | dict): Person object or dictionary with update fields.\n\n    Returns:\n        Optional[Person]: Updated Person object if successful, None otherwise.\n\n    \"\"\"\n    collection = self.get_collection()\n\n    oid = Database.convert_to_objectid(person_id)\n    if oid is None:\n        logger.warning(f\"ID non valido per aggiornamento: {person_id}\")\n        return None\n\n\n    if person_id != str(oid):\n        logger.warning(f\"ID non coerente per aggiornamento: {person_id} vs {str(oid)}\")\n        return None\n\n    if isinstance(update_data, Person):\n        payload = self._person_to_document(update_data)\n    else:\n        payload = dict(update_data)\n\n    payload.pop(\"_id\", None)\n    payload.pop(\"id\", None)\n\n    if not payload:\n        logger.warning(\"Nessun dato valido fornito per l'aggiornamento.\")\n        return None\n\n    updated_doc = collection.find_one_and_update(\n        {\"_id\": oid},\n        {\"$set\": payload},\n        return_document=ReturnDocument.AFTER\n    )\n\n    if updated_doc:\n        person = self._person_from_doc(updated_doc)\n        return person\n\n    logger.warning(f\"Nessuna persona trovata con ID {person_id} per l'aggiornamento.\")\n    return None\n</code></pre>"},{"location":"services/recognition/","title":"Face Recognition Service","text":"<p>Face detection and recognition engine using InsightFace and FAISS.</p>"},{"location":"services/recognition/#faceengine-class","title":"FaceEngine Class","text":""},{"location":"services/recognition/#app.services.recognition.FaceEngine","title":"app.services.recognition.FaceEngine","text":"<p>Face recognition engine using InsightFace and FAISS for similarity search.</p> <p>Manages face detection, embedding extraction, and person identification using pre-trained models and efficient vector similarity search.</p> <p>Attributes:</p> Name Type Description <code>feature_matrix</code> <code>ndarray | None</code> <p>Normalized matrix of face embeddings.</p> <code>user_map</code> <code>list[Person]</code> <p>List of Person objects corresponding to embeddings.</p> <code>index</code> <p>FAISS index for fast similarity search (optional).</p> <code>app</code> <p>InsightFace FaceAnalysis model instance.</p> Source code in <code>backend/app/services/recognition.py</code> <pre><code>class FaceEngine:\n    \"\"\"Face recognition engine using InsightFace and FAISS for similarity search.\n\n    Manages face detection, embedding extraction, and person identification\n    using pre-trained models and efficient vector similarity search.\n\n    Attributes:\n        feature_matrix (np.ndarray | None): Normalized matrix of face embeddings.\n        user_map (list[Person]): List of Person objects corresponding to embeddings.\n        index: FAISS index for fast similarity search (optional).\n        app: InsightFace FaceAnalysis model instance.\n\n    \"\"\"\n\n    def __init__(self, people : list):\n        \"\"\"Initialize FaceEngine with person data.\n\n        Args:\n            people (list): List of Person objects with face encodings to initialize the engine.\n\n        \"\"\"\n        self.feature_matrix : np.ndarray | None = None\n        self.user_map: list[Person] = []\n        self.index = None\n        self.app = self._initialize_model(people)\n\n\n    def _initialize_faiss_index(self, enable_gpu=False):\n        \"\"\"Initialize FAISS index for fast similarity search.\n\n        Creates FAISS index from feature matrix, optionally using GPU acceleration\n        if available and requested.\n\n        Args:\n            enable_gpu (bool): Whether to attempt GPU acceleration. Default: False.\n\n        \"\"\"\n        if not FAISS_AVAILABLE or self.feature_matrix is None:\n            return\n\n        d = self.feature_matrix.shape[1]\n\n        cpu_index = faiss.IndexFlatIP(d)\n        cpu_index.add(self.feature_matrix.astype(np.float32))\n\n        # Tentativo passaggio a GPU (solo se richiesto e disponibile)\n        if enable_gpu and FAISS_GPU_AVAILABLE:\n            try:\n                # Risorse GPU standard (necessarie per FAISS GPU)\n                self.gpu_resources = faiss.StandardGpuResources()\n\n                # Sposta l'indice dalla RAM (CPU) alla VRAM (GPU)\n                self.index = faiss.index_cpu_to_gpu(self.gpu_resources, 0, cpu_index)\n                logger.info(f\"FAISS: Indice spostato su GPU (CUDA attiva)\")\n            except Exception as e:\n                logger.warning(f\"FAISS GPU fallito (fallback su CPU): {e}\")\n                self.index = cpu_index\n        else:\n            self.index = cpu_index\n            mode = \"CPU (Forzata)\" if not enable_gpu else \"CPU (GPU non disp.)\"\n            logger.info(f\"FAISS: Indice creato su {mode}\")\n\n    def _initialize_model(self, people):\n        \"\"\"Initialize InsightFace model and build feature matrix from people data.\n\n        Selects best available execution provider (CUDA, CoreML, DML, or CPU),\n        initializes the face analysis model, and builds normalized feature matrix\n        from person encodings. Initializes FAISS index if embeddings are available.\n\n        Args:\n            people (list): List of Person objects with encodings.\n\n        Returns:\n            FaceAnalysis: Initialized InsightFace model instance.\n\n        Raises:\n            SystemExit: If model initialization fails.\n            ValueError: If feature matrix and user_map dimensions don't match.\n\n        \"\"\"\n        available_providers = ort.get_available_providers()\n        providers_list = []\n\n        using_cuda = False\n\n        if 'CUDAExecutionProvider' in available_providers:\n            providers_list.append('CUDAExecutionProvider')\n            using_cuda = True\n        elif 'CoreMLExecutionProvider' in available_providers:\n            providers_list.append('CoreMLExecutionProvider') \n        elif 'DmlExecutionProvider' in available_providers:\n            providers_list.append('DmlExecutionProvider')\n\n        providers_list.append('CPUExecutionProvider')\n\n        try:\n            model = FaceAnalysis(name=MODEL, providers=providers_list)\n            model.prepare(ctx_id=0, det_size=(DETECTION_SIZE, DETECTION_SIZE))\n        except Exception as e:\n            logger.critical(f\"Impossibile avviare il modello: {e}\")\n            sys.exit(1)\n\n        all_embeddings = []\n        self.user_map = []\n        embedding_dimension = None\n\n        for person in people:\n            if person.encoding is None or not person.encoding:\n                continue\n\n            for hash, vector in person.encoding.items():\n                try:\n                    if vector is None or not isinstance(vector, (list, np.ndarray)) or len(vector) == 0:\n                        continue\n\n                    np_vector = np.array(vector, dtype=np.float32)\n                    if np_vector.ndim &gt; 1:\n                        np_vector = np_vector.flatten()\n\n                    if embedding_dimension is None:\n                        embedding_dimension = len(np_vector)\n                    elif len(np_vector) != embedding_dimension:\n                        logger.error(f\"Embedding con dimensione errata per {person.name} {person.surname} (hash: {hash})\")\n                        continue\n\n                    if np.any(np.isnan(np_vector)) or np.any(np.isinf(np_vector)):\n                        logger.error(f\"Embedding con valori NaN/Inf per {person.name} {person.surname} (hash: {hash})\")\n                        continue\n\n                    all_embeddings.append(np_vector)\n                    self.user_map.append(person)\n                except Exception as e:\n                    logger.error(f\"Errore nel processare encoding per {person.name} {person.surname} (hash: {hash}): {e}\")\n                    continue\n\n        if len(all_embeddings) &gt; 0:\n            self.feature_matrix = np.vstack(all_embeddings)\n            if len(self.user_map) != self.feature_matrix.shape[0]:\n                logger.error(f\"ERRORE CRITICO: Dimensione user_map ({len(self.user_map)}) non corrisponde a feature_matrix ({self.feature_matrix.shape[0]})\")\n                raise ValueError(\"Inconsistenza tra user_map e feature_matrix\")\n            if np.any(np.isnan(self.feature_matrix)) or np.any(np.isinf(self.feature_matrix)):\n                logger.error(\"feature_matrix contiene valori NaN o Inf!\")\n\n            # Pre-normalizza la feature_matrix una volta sola (ottimizzazione prestazioni)\n            feature_norms = np.linalg.norm(self.feature_matrix, axis=1, keepdims=True)\n            feature_norms[feature_norms == 0] = 1.0\n            self.feature_matrix = self.feature_matrix / feature_norms\n            logger.info(f\"feature_matrix pre-normalizzata: {self.feature_matrix.shape[0]} embeddings\")\n            self._initialize_faiss_index(using_cuda)\n        else:\n            self.feature_matrix = None\n            logger.warning(\"Database vuoto: nessun encoding trovato.\")\n        return model\n\n    def analyze_frame(self, frame_bgr: np.ndarray) -&gt; list:\n        \"\"\"Detect and extract face embeddings from a BGR frame.\n\n        Args:\n            frame_bgr (np.ndarray): Input image frame in BGR format.\n\n        Returns:\n            list: List of Face objects with detected faces and embeddings.\n                Returns empty list if frame is None or no faces detected.\n\n        \"\"\"\n        if frame_bgr is None:\n            return []\n\n        faces = self.app.get(frame_bgr)\n        return faces\n\n    def analyze_img(self, path: str | os.PathLike) -&gt; dict | None:\n        \"\"\"Analyze an image file and extract face embedding.\n\n        Validates and normalizes the image, detects faces, and extracts\n        embedding from the largest detected face.\n\n        Args:\n            path: Path to image file (Path object or string).\n\n        Returns:\n            dict | None: Dictionary mapping image hash to embedding list, or None if\n                no valid face detected.\n\n        \"\"\"\n        pic = img.ImgValidation(path, delete=True)\n\n        if pic.path is None:\n            return None\n\n        face = self.analyze_frame(cv2.imread(pic.path))\n\n        if len(face) == 0:\n            return None\n\n        # Seleziona il volto pi\u00f9 grande in caso di pi\u00f9 volti\n        primary_face = max(face, key=lambda x: (x.bbox[2]-x.bbox[0]) * (x.bbox[3]-x.bbox[1]))\n        embedding_list = primary_face.embedding.tolist()\n\n        return {pic.hash : embedding_list}\n\n    def identify(self, target_data: np.ndarray | list[np.ndarray], threshold: float = 0.5) -&gt; list[tuple[Optional[Person], float]]:\n        \"\"\"Identify persons from face embeddings using similarity search.\n\n        Uses FAISS index (if available) or numpy dot product to find the most\n        similar person embeddings. Returns matches above the similarity threshold.\n\n        Args:\n            target_data: Single embedding (np.ndarray) or list of embeddings to identify.\n            threshold (float): Minimum similarity score (0.0-1.0) to consider a match.\n                Default: 0.5.\n\n        Returns:\n            list[tuple[Optional[Person], float]]: List of tuples (Person, score) for each input embedding.\n                Returns (None, score) if no match above threshold found.\n\n        \"\"\"\n        # Controllo Database\n        if self.feature_matrix is None:\n            logger.warning(\"feature_matrix \u00e8 None: database vuoto o non inizializzato\")\n            n_items = len(target_data) if isinstance(target_data, list) else 1\n            return [(None, 0.0)] * n_items\n\n        # Preparazione Input (Matrice N x D)\n        if isinstance(target_data, list) and len(target_data) &gt; 0 and isinstance(target_data[0], np.ndarray):\n            input_matrix = np.stack(target_data)\n        else:\n            input_matrix = np.array(target_data, dtype=np.float32)\n\n        if input_matrix.ndim == 1:\n            input_matrix = input_matrix.reshape(1, -1)\n\n        # Importante: FAISS vuole float32\n        input_matrix = input_matrix.astype(np.float32)\n\n        # Normalizzazione L2\n        norms = np.linalg.norm(input_matrix, axis=1, keepdims=True)\n        norms[norms == 0] = 1e-10\n        normalized_matrix = input_matrix / norms\n\n        # --- FAISS vs NUMPY ---\n        best_indices = None\n        best_scores = None\n\n        # Controllo se self.index esiste (creato da _initialize_faiss_index)\n        if getattr(self, 'index', None) is not None:\n            # k=1 significa \"trova solo il pi\u00f9 simile\"\n            scores, indices = self.index.search(normalized_matrix, k=1)\n\n            # Appiattiamo i risultati (da matrice Nx1 a vettori N)\n            best_scores = scores.flatten()\n            best_indices = indices.flatten()\n        else:\n            # PERCORSO NUMPY\n            all_scores = np.dot(normalized_matrix, self.feature_matrix.T)\n            best_indices = np.argmax(all_scores, axis=1)\n            best_scores = np.max(all_scores, axis=1)\n\n        # Formattazione Risultati\n        results = []\n        for idx, score in zip(best_indices, best_scores):\n            idx = int(idx)     # Cast a int nativo Python\n            score = float(score) # Cast a float nativo Python\n\n            if score &gt; threshold:\n                if idx &lt; len(self.user_map):\n                    results.append((self.user_map[idx], score))\n                else:\n                    logger.error(f\"Index {idx} fuori range user_map\")\n                    results.append((None, score))\n            else:\n                results.append((None, score))\n\n        return results\n</code></pre>"},{"location":"services/recognition/#app.services.recognition.FaceEngine-functions","title":"Functions","text":""},{"location":"services/recognition/#app.services.recognition.FaceEngine.__init__","title":"__init__","text":"<pre><code>__init__(people)\n</code></pre> <p>Initialize FaceEngine with person data.</p> <p>Parameters:</p> Name Type Description Default <code>people</code> <code>list</code> <p>List of Person objects with face encodings to initialize the engine.</p> required Source code in <code>backend/app/services/recognition.py</code> <pre><code>def __init__(self, people : list):\n    \"\"\"Initialize FaceEngine with person data.\n\n    Args:\n        people (list): List of Person objects with face encodings to initialize the engine.\n\n    \"\"\"\n    self.feature_matrix : np.ndarray | None = None\n    self.user_map: list[Person] = []\n    self.index = None\n    self.app = self._initialize_model(people)\n</code></pre>"},{"location":"services/recognition/#app.services.recognition.FaceEngine.analyze_frame","title":"analyze_frame","text":"<pre><code>analyze_frame(frame_bgr)\n</code></pre> <p>Detect and extract face embeddings from a BGR frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_bgr</code> <code>ndarray</code> <p>Input image frame in BGR format.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of Face objects with detected faces and embeddings. Returns empty list if frame is None or no faces detected.</p> Source code in <code>backend/app/services/recognition.py</code> <pre><code>def analyze_frame(self, frame_bgr: np.ndarray) -&gt; list:\n    \"\"\"Detect and extract face embeddings from a BGR frame.\n\n    Args:\n        frame_bgr (np.ndarray): Input image frame in BGR format.\n\n    Returns:\n        list: List of Face objects with detected faces and embeddings.\n            Returns empty list if frame is None or no faces detected.\n\n    \"\"\"\n    if frame_bgr is None:\n        return []\n\n    faces = self.app.get(frame_bgr)\n    return faces\n</code></pre>"},{"location":"services/recognition/#app.services.recognition.FaceEngine.analyze_img","title":"analyze_img","text":"<pre><code>analyze_img(path)\n</code></pre> <p>Analyze an image file and extract face embedding.</p> <p>Validates and normalizes the image, detects faces, and extracts embedding from the largest detected face.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | PathLike</code> <p>Path to image file (Path object or string).</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Dictionary mapping image hash to embedding list, or None if no valid face detected.</p> Source code in <code>backend/app/services/recognition.py</code> <pre><code>def analyze_img(self, path: str | os.PathLike) -&gt; dict | None:\n    \"\"\"Analyze an image file and extract face embedding.\n\n    Validates and normalizes the image, detects faces, and extracts\n    embedding from the largest detected face.\n\n    Args:\n        path: Path to image file (Path object or string).\n\n    Returns:\n        dict | None: Dictionary mapping image hash to embedding list, or None if\n            no valid face detected.\n\n    \"\"\"\n    pic = img.ImgValidation(path, delete=True)\n\n    if pic.path is None:\n        return None\n\n    face = self.analyze_frame(cv2.imread(pic.path))\n\n    if len(face) == 0:\n        return None\n\n    # Seleziona il volto pi\u00f9 grande in caso di pi\u00f9 volti\n    primary_face = max(face, key=lambda x: (x.bbox[2]-x.bbox[0]) * (x.bbox[3]-x.bbox[1]))\n    embedding_list = primary_face.embedding.tolist()\n\n    return {pic.hash : embedding_list}\n</code></pre>"},{"location":"services/recognition/#app.services.recognition.FaceEngine.identify","title":"identify","text":"<pre><code>identify(target_data, threshold=0.5)\n</code></pre> <p>Identify persons from face embeddings using similarity search.</p> <p>Uses FAISS index (if available) or numpy dot product to find the most similar person embeddings. Returns matches above the similarity threshold.</p> <p>Parameters:</p> Name Type Description Default <code>target_data</code> <code>ndarray | list[ndarray]</code> <p>Single embedding (np.ndarray) or list of embeddings to identify.</p> required <code>threshold</code> <code>float</code> <p>Minimum similarity score (0.0-1.0) to consider a match. Default: 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>list[tuple[Optional[Person], float]]</code> <p>list[tuple[Optional[Person], float]]: List of tuples (Person, score) for each input embedding. Returns (None, score) if no match above threshold found.</p> Source code in <code>backend/app/services/recognition.py</code> <pre><code>def identify(self, target_data: np.ndarray | list[np.ndarray], threshold: float = 0.5) -&gt; list[tuple[Optional[Person], float]]:\n    \"\"\"Identify persons from face embeddings using similarity search.\n\n    Uses FAISS index (if available) or numpy dot product to find the most\n    similar person embeddings. Returns matches above the similarity threshold.\n\n    Args:\n        target_data: Single embedding (np.ndarray) or list of embeddings to identify.\n        threshold (float): Minimum similarity score (0.0-1.0) to consider a match.\n            Default: 0.5.\n\n    Returns:\n        list[tuple[Optional[Person], float]]: List of tuples (Person, score) for each input embedding.\n            Returns (None, score) if no match above threshold found.\n\n    \"\"\"\n    # Controllo Database\n    if self.feature_matrix is None:\n        logger.warning(\"feature_matrix \u00e8 None: database vuoto o non inizializzato\")\n        n_items = len(target_data) if isinstance(target_data, list) else 1\n        return [(None, 0.0)] * n_items\n\n    # Preparazione Input (Matrice N x D)\n    if isinstance(target_data, list) and len(target_data) &gt; 0 and isinstance(target_data[0], np.ndarray):\n        input_matrix = np.stack(target_data)\n    else:\n        input_matrix = np.array(target_data, dtype=np.float32)\n\n    if input_matrix.ndim == 1:\n        input_matrix = input_matrix.reshape(1, -1)\n\n    # Importante: FAISS vuole float32\n    input_matrix = input_matrix.astype(np.float32)\n\n    # Normalizzazione L2\n    norms = np.linalg.norm(input_matrix, axis=1, keepdims=True)\n    norms[norms == 0] = 1e-10\n    normalized_matrix = input_matrix / norms\n\n    # --- FAISS vs NUMPY ---\n    best_indices = None\n    best_scores = None\n\n    # Controllo se self.index esiste (creato da _initialize_faiss_index)\n    if getattr(self, 'index', None) is not None:\n        # k=1 significa \"trova solo il pi\u00f9 simile\"\n        scores, indices = self.index.search(normalized_matrix, k=1)\n\n        # Appiattiamo i risultati (da matrice Nx1 a vettori N)\n        best_scores = scores.flatten()\n        best_indices = indices.flatten()\n    else:\n        # PERCORSO NUMPY\n        all_scores = np.dot(normalized_matrix, self.feature_matrix.T)\n        best_indices = np.argmax(all_scores, axis=1)\n        best_scores = np.max(all_scores, axis=1)\n\n    # Formattazione Risultati\n    results = []\n    for idx, score in zip(best_indices, best_scores):\n        idx = int(idx)     # Cast a int nativo Python\n        score = float(score) # Cast a float nativo Python\n\n        if score &gt; threshold:\n            if idx &lt; len(self.user_map):\n                results.append((self.user_map[idx], score))\n            else:\n                logger.error(f\"Index {idx} fuori range user_map\")\n                results.append((None, score))\n        else:\n            results.append((None, score))\n\n    return results\n</code></pre>"},{"location":"utils/constants/","title":"Constants","text":"<p>Enumeration types for the application.</p>"},{"location":"utils/constants/#relationshiptype","title":"RelationshipType","text":""},{"location":"utils/constants/#app.utils.constants.RelationshipType","title":"app.utils.constants.RelationshipType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of relationship types between persons.</p> <p>Defines various relationship types that can exist between a person and the primary user in the system.</p> Source code in <code>backend/app/utils/constants.py</code> <pre><code>class RelationshipType(str, Enum):\n    \"\"\"Enumeration of relationship types between persons.\n\n    Defines various relationship types that can exist between a person\n    and the primary user in the system.\n\n    \"\"\"\n\n    MADRE = \"madre\"\n    PADRE = \"padre\"\n    GENITORE = \"genitore\"\n    FRATELLO = \"fratello\"\n    SORELLA = \"sorella\"\n    FIGLIO = \"figlio\"\n    FIGLIA = \"figlia\"\n    AMICO = \"amico\"\n    CONIUGE = \"coniuge\"\n    PARTNER = \"partner\"\n    ASSISTENTE = \"assistente\"\n    MANAGER = \"manager\"\n    ALTRO = \"altro\"\n    COINQUILINO = \"coinquilino\"\n    MEDICO = \"medico\"\n    EMERGENZA = \"emergenza\"\n    MEMBRO_DELLA_FAMIGLIA = \"membro della famiglia\"\n    DOCENTE = \"docente\"\n    BADANTE = \"badante\"\n    TUTORE = \"tutore\"\n    ASSISTENTE_SOCIALE = \"assistente sociale\"\n    SCUOLA = \"scuola\"\n    CENTRO_DIURNO = \"centro diurno\"\n</code></pre>"},{"location":"utils/constants/#roletype","title":"RoleType","text":""},{"location":"utils/constants/#app.utils.constants.RoleType","title":"app.utils.constants.RoleType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of person roles in the system.</p> <p>Defines the role types that a person can have within the application.</p> Source code in <code>backend/app/utils/constants.py</code> <pre><code>class RoleType(str, Enum):\n    \"\"\"Enumeration of person roles in the system.\n\n    Defines the role types that a person can have within the application.\n\n    \"\"\"\n\n    USER = \"user\"\n    GUEST = \"guest\"\n</code></pre>"},{"location":"utils/img/","title":"Image Validation Utility","text":"<p>Image validation and conversion utility.</p>"},{"location":"utils/img/#imgvalidation-class","title":"ImgValidation Class","text":""},{"location":"utils/img/#app.utils.img.ImgValidation","title":"app.utils.img.ImgValidation","text":"<p>Image validation and conversion utility.</p> <p>Validates image files, converts them to PNG format, and generates MD5 hash for identification. Supports multiple image formats including HEIC.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str | None</code> <p>Path to the normalized PNG image file.</p> <code>name</code> <code>str | None</code> <p>Image filename without extension.</p> <code>ext</code> <code>str | None</code> <p>File extension (always .png after normalization).</p> <code>hash</code> <code>str | None</code> <p>MD5 hash of the image content.</p> Source code in <code>backend/app/utils/img.py</code> <pre><code>class ImgValidation:\n    \"\"\"Image validation and conversion utility.\n\n    Validates image files, converts them to PNG format, and generates\n    MD5 hash for identification. Supports multiple image formats including HEIC.\n\n    Attributes:\n        path (str | None): Path to the normalized PNG image file.\n        name (str | None): Image filename without extension.\n        ext (str | None): File extension (always .png after normalization).\n        hash (str | None): MD5 hash of the image content.\n\n    \"\"\"\n\n    def __init__(self, path: str, delete : bool = False):\n        \"\"\"Initialize ImgValidation and normalize the image.\n\n        Args:\n            path (str): Path to the image file to validate.\n            delete (bool): Whether to delete the original file after conversion.\n                Default: False.\n\n        \"\"\"\n        self.path = None\n        self.name = None\n        self.ext = None\n        self.hash = None\n        self.normalize_img(path, delete)\n\n\n    @property\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if the image validation was successful.\n\n        Returns:\n            bool: True if all attributes (path, name, ext, hash) are set, False otherwise.\n\n        \"\"\"\n        return self.path is not None and self.name is not None and self.ext is not None and self.hash is not None \n\n    @staticmethod\n    def convert_any_to_png(path: str, name: str, ext: str, delete: bool = False) -&gt; str | None:\n        \"\"\"Convert image file to PNG format.\n\n        Converts supported image formats to PNG and saves in configured images folder.\n        Supports: PNG, JPG, JPEG, BMP, TIFF, GIF, HEIC.\n\n        Args:\n            path (str): Original image file path.\n            name (str): Base filename without extension.\n            ext (str): Original file extension.\n            delete (bool): Whether to delete original file after conversion. Default: False.\n\n        Returns:\n            str | None: Path to converted PNG file, or None if conversion fails.\n\n        \"\"\"\n        ext = ext.lower()\n        filepng = f\"{path_settings.imgsfolder}/{name}.png\"\n\n        if ext == \".png\" and filepng == path:\n            return path\n\n        if ext == \".heic\":\n            heif.register_heif_opener()\n\n        supported_ext = [\".png\", \".jpg\", \".jpeg\", \".bmp\", \".tiff\", \".gif\", \".heic\"]\n\n        if ext not in supported_ext:\n            logger.error(\"Formato non supportato per la conversione.\")\n            return None\n\n        try:\n            img = Image.open(path)\n            img.save(filepng, \"PNG\")\n        except Exception as e:\n            logger.error(f\"Errore durante la conversione: {e}\")\n            return None\n\n        try:\n            if os.path.exists(path) and delete == True:\n                os.remove(path)\n        except Exception as e:\n            logger.error(f\"Errore durante la rimozione {path} originale: {e}\")\n\n        return filepng\n\n    @staticmethod\n    def validate_png(path: str) -&gt; bool:\n        \"\"\"Validate that a file exists and has PNG extension.\n\n        Args:\n            path (str): File path to validate.\n\n        Returns:\n            bool: True if file exists and has .png extension, False otherwise.\n\n        \"\"\"\n        if path is None or not os.path.exists(path):\n            return False  \n        name, ext = os.path.splitext(path)\n        if ext.lower() == \".png\":\n            return True\n        return False\n\n    @staticmethod\n    def hash_img(path: str) -&gt; str | None:\n        \"\"\"Generate MD5 hash of PNG image content.\n\n        Args:\n            path (str): Path to PNG image file.\n\n        Returns:\n            str | None: MD5 hash hexdigest if valid PNG, None otherwise.\n\n        \"\"\"\n        if not ImgValidation.validate_png(path):\n            return None\n\n        img_hash = hashlib.md5(Image.open(path).tobytes())\n        return img_hash.hexdigest()\n\n    def normalize_img(self, path: str, delete: bool) -&gt; bool:\n        \"\"\"Normalize image: convert to PNG, validate, and generate hash.\n\n        Processes image file through conversion, validation, and hashing pipeline.\n        Sets instance attributes (path, name, ext, hash) on success.\n\n        Args:\n            path (str): Path to image file to normalize.\n            delete (bool): Whether to delete original file after conversion.\n\n        Returns:\n            bool: True if normalization successful, False otherwise.\n\n        \"\"\"\n        if not os.path.exists(path):\n            return False\n\n        if delete is None:\n            delete = False\n\n        filename_with_ext = os.path.basename(path)\n        name, ext = os.path.splitext(filename_with_ext)\n        filepng = ImgValidation.convert_any_to_png(path, name, ext, delete)\n        if ImgValidation.validate_png(filepng):\n            hash = ImgValidation.hash_img(filepng)\n            name, ext = os.path.splitext(filepng)\n            if hash is not None:\n                self.path = filepng\n                self.name = name\n                self.ext = ext\n                self.hash = hash\n                return True\n        return False\n\n    def compare_img(self, path: str) -&gt; bool:\n        \"\"\"Compare this image with another image file by hash.\n\n        Args:\n            path (str): Path to image file to compare with.\n\n        Returns:\n            bool: True if images have the same MD5 hash, False otherwise.\n\n        \"\"\"\n        if not self.is_valid :\n            logger.warning(f\"{self.path} non \u00e8 un percorso valido\")\n            return False\n\n        img = ImgValidation(path)\n        if img.is_valid and (self.hash == img.hash):\n            return True\n        return False\n</code></pre>"},{"location":"utils/img/#app.utils.img.ImgValidation-attributes","title":"Attributes","text":""},{"location":"utils/img/#app.utils.img.ImgValidation.is_valid","title":"is_valid  <code>property</code>","text":"<pre><code>is_valid\n</code></pre> <p>Check if the image validation was successful.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all attributes (path, name, ext, hash) are set, False otherwise.</p>"},{"location":"utils/img/#app.utils.img.ImgValidation-functions","title":"Functions","text":""},{"location":"utils/img/#app.utils.img.ImgValidation.__init__","title":"__init__","text":"<pre><code>__init__(path, delete=False)\n</code></pre> <p>Initialize ImgValidation and normalize the image.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the image file to validate.</p> required <code>delete</code> <code>bool</code> <p>Whether to delete the original file after conversion. Default: False.</p> <code>False</code> Source code in <code>backend/app/utils/img.py</code> <pre><code>def __init__(self, path: str, delete : bool = False):\n    \"\"\"Initialize ImgValidation and normalize the image.\n\n    Args:\n        path (str): Path to the image file to validate.\n        delete (bool): Whether to delete the original file after conversion.\n            Default: False.\n\n    \"\"\"\n    self.path = None\n    self.name = None\n    self.ext = None\n    self.hash = None\n    self.normalize_img(path, delete)\n</code></pre>"},{"location":"utils/img/#app.utils.img.ImgValidation.compare_img","title":"compare_img","text":"<pre><code>compare_img(path)\n</code></pre> <p>Compare this image with another image file by hash.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to image file to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if images have the same MD5 hash, False otherwise.</p> Source code in <code>backend/app/utils/img.py</code> <pre><code>def compare_img(self, path: str) -&gt; bool:\n    \"\"\"Compare this image with another image file by hash.\n\n    Args:\n        path (str): Path to image file to compare with.\n\n    Returns:\n        bool: True if images have the same MD5 hash, False otherwise.\n\n    \"\"\"\n    if not self.is_valid :\n        logger.warning(f\"{self.path} non \u00e8 un percorso valido\")\n        return False\n\n    img = ImgValidation(path)\n    if img.is_valid and (self.hash == img.hash):\n        return True\n    return False\n</code></pre>"},{"location":"utils/img/#app.utils.img.ImgValidation.convert_any_to_png","title":"convert_any_to_png  <code>staticmethod</code>","text":"<pre><code>convert_any_to_png(path, name, ext, delete=False)\n</code></pre> <p>Convert image file to PNG format.</p> <p>Converts supported image formats to PNG and saves in configured images folder. Supports: PNG, JPG, JPEG, BMP, TIFF, GIF, HEIC.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Original image file path.</p> required <code>name</code> <code>str</code> <p>Base filename without extension.</p> required <code>ext</code> <code>str</code> <p>Original file extension.</p> required <code>delete</code> <code>bool</code> <p>Whether to delete original file after conversion. Default: False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: Path to converted PNG file, or None if conversion fails.</p> Source code in <code>backend/app/utils/img.py</code> <pre><code>@staticmethod\ndef convert_any_to_png(path: str, name: str, ext: str, delete: bool = False) -&gt; str | None:\n    \"\"\"Convert image file to PNG format.\n\n    Converts supported image formats to PNG and saves in configured images folder.\n    Supports: PNG, JPG, JPEG, BMP, TIFF, GIF, HEIC.\n\n    Args:\n        path (str): Original image file path.\n        name (str): Base filename without extension.\n        ext (str): Original file extension.\n        delete (bool): Whether to delete original file after conversion. Default: False.\n\n    Returns:\n        str | None: Path to converted PNG file, or None if conversion fails.\n\n    \"\"\"\n    ext = ext.lower()\n    filepng = f\"{path_settings.imgsfolder}/{name}.png\"\n\n    if ext == \".png\" and filepng == path:\n        return path\n\n    if ext == \".heic\":\n        heif.register_heif_opener()\n\n    supported_ext = [\".png\", \".jpg\", \".jpeg\", \".bmp\", \".tiff\", \".gif\", \".heic\"]\n\n    if ext not in supported_ext:\n        logger.error(\"Formato non supportato per la conversione.\")\n        return None\n\n    try:\n        img = Image.open(path)\n        img.save(filepng, \"PNG\")\n    except Exception as e:\n        logger.error(f\"Errore durante la conversione: {e}\")\n        return None\n\n    try:\n        if os.path.exists(path) and delete == True:\n            os.remove(path)\n    except Exception as e:\n        logger.error(f\"Errore durante la rimozione {path} originale: {e}\")\n\n    return filepng\n</code></pre>"},{"location":"utils/img/#app.utils.img.ImgValidation.hash_img","title":"hash_img  <code>staticmethod</code>","text":"<pre><code>hash_img(path)\n</code></pre> <p>Generate MD5 hash of PNG image content.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to PNG image file.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: MD5 hash hexdigest if valid PNG, None otherwise.</p> Source code in <code>backend/app/utils/img.py</code> <pre><code>@staticmethod\ndef hash_img(path: str) -&gt; str | None:\n    \"\"\"Generate MD5 hash of PNG image content.\n\n    Args:\n        path (str): Path to PNG image file.\n\n    Returns:\n        str | None: MD5 hash hexdigest if valid PNG, None otherwise.\n\n    \"\"\"\n    if not ImgValidation.validate_png(path):\n        return None\n\n    img_hash = hashlib.md5(Image.open(path).tobytes())\n    return img_hash.hexdigest()\n</code></pre>"},{"location":"utils/img/#app.utils.img.ImgValidation.normalize_img","title":"normalize_img","text":"<pre><code>normalize_img(path, delete)\n</code></pre> <p>Normalize image: convert to PNG, validate, and generate hash.</p> <p>Processes image file through conversion, validation, and hashing pipeline. Sets instance attributes (path, name, ext, hash) on success.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to image file to normalize.</p> required <code>delete</code> <code>bool</code> <p>Whether to delete original file after conversion.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if normalization successful, False otherwise.</p> Source code in <code>backend/app/utils/img.py</code> <pre><code>def normalize_img(self, path: str, delete: bool) -&gt; bool:\n    \"\"\"Normalize image: convert to PNG, validate, and generate hash.\n\n    Processes image file through conversion, validation, and hashing pipeline.\n    Sets instance attributes (path, name, ext, hash) on success.\n\n    Args:\n        path (str): Path to image file to normalize.\n        delete (bool): Whether to delete original file after conversion.\n\n    Returns:\n        bool: True if normalization successful, False otherwise.\n\n    \"\"\"\n    if not os.path.exists(path):\n        return False\n\n    if delete is None:\n        delete = False\n\n    filename_with_ext = os.path.basename(path)\n    name, ext = os.path.splitext(filename_with_ext)\n    filepng = ImgValidation.convert_any_to_png(path, name, ext, delete)\n    if ImgValidation.validate_png(filepng):\n        hash = ImgValidation.hash_img(filepng)\n        name, ext = os.path.splitext(filepng)\n        if hash is not None:\n            self.path = filepng\n            self.name = name\n            self.ext = ext\n            self.hash = hash\n            return True\n    return False\n</code></pre>"},{"location":"utils/img/#app.utils.img.ImgValidation.validate_png","title":"validate_png  <code>staticmethod</code>","text":"<pre><code>validate_png(path)\n</code></pre> <p>Validate that a file exists and has PNG extension.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>File path to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if file exists and has .png extension, False otherwise.</p> Source code in <code>backend/app/utils/img.py</code> <pre><code>@staticmethod\ndef validate_png(path: str) -&gt; bool:\n    \"\"\"Validate that a file exists and has PNG extension.\n\n    Args:\n        path (str): File path to validate.\n\n    Returns:\n        bool: True if file exists and has .png extension, False otherwise.\n\n    \"\"\"\n    if path is None or not os.path.exists(path):\n        return False  \n    name, ext = os.path.splitext(path)\n    if ext.lower() == \".png\":\n        return True\n    return False\n</code></pre>"}]}